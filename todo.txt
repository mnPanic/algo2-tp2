Trie
    Pasar en limpio:
        - Hacer que sea *solución y que devuelva una ref.
        - Hacer que nuevoNodo sea iNuevoNodo
        - Abs y rep
        - Hacer que definir devuelva una referencia al significado
            (chequear aspectos de aliasing)
    Agregar un conjunto de claves para devolver
        AGREGAR AL REP

General
    - Agregar "typedef" al principio para
        Jugador
        Fantasma
        Evento
        Pos 
        Dir
        Cambiar mapa disparos para que en vez de tuple(nat nat) tenga
            pasoDisparos
                pasoDispFan
                pasoDispPJ
    - Chequear las cosas que van por ref y copia
    - Agregar justificaciones de complejidades
    - Chequear las cosas por ref y por copias (Recordar que:
        Con la notación de módulos de la materia: apilar(in/out pila : Pila, in x : Elemento)
        Con notación de C++: void Pila::apilar(const Elemento& x))

Juego
    - Hacer que eventos del PJ sea una lista enlazada para que agregar sea O(1)
    - EjecutarAccion
    - (TAD) Precondicion en iniciar -> evt fantasma no vacio
    - Pre y Post condiciones de funciones auxiliares (IMPORTANTE ESTO NO LO VIMOS PERO ESTÁ EN EL TP)

    - Arreglar interfaz
    - Agregar todas las operaciones que piden
    - Agregar observadores

    - Rep y abs

Mapa
    Valida?(m, pos) -> bool

Accion
    Agregar las cosas de Evento
        
        En rep/abs de Juego
            Existe un n tq la long de los eventos es n * 2 + 5 => 
            los primeros n son los ultimos (n+5 a long - 1) invertidos.
            entre n y n+5 son "nada".
    
    Avanzar(pos, dir) -> pos
        Dada una posicion, la avanza en una dir sin importar si es v?lida.
    
    Con Avanzar refactorizar Aplicar
        
