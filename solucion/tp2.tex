% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a página completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Cátedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={Módulos básicos},
 pdftitle={Módulos básicos de diseño},
 pdfsubject={Módulos básicos de diseño}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$1^\mathrm{er}$ cuatrimestre de 2019}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Apunte de Módulos Básicos (v.\ 0.3$\alpha$)}
\author{Algoritmos y Estructuras de Datos II, DC, UBA.}
\date{\Cuatrimestre}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{\Cuatrimestre}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

%pagina de titulo
\thispagestyle{empty}
\maketitle
\tableofcontents

\newpage

\section{Módulo X}

Aqui va la descripción

\begin{Interfaz}
  \textbf{generos}: \TipoVariable{x}.
  \textbf{se explica con}: \tadNombre{X}.

  \Titulo{Operaciones básicas de X}
  \InterfazFuncion{nuevoX}{\In{n}{nat}}{X}%
  {$res \igobs nuevaHab(n)$}%
  [$\Theta(n^2)$]
  [genera un mapa de tamano n x n.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación de X}

  El objetivo de este módulo es implementar una lista doblemente enlazada con punteros al principio y al fin.  Para simplificar un poco el manejo de la estructura, vamos a reemplazarla por una lista circular, donde el siguiente del último apunta al primero y el anterior del primero apunta al último.  La estructura de representación, su invariante de representación y su función de abstracción son las siguientes.

  \begin{Estructura}{mapa}[m]
    \begin{Tupla}[m]
      \tupItem{tamano}{nat}%
      \tupItem{casilleros}{vec(vec(bool))}%
    \end{Tupla}
  \end{Estructura}

  \Rep[mapa][m]{
    La longitud de m.casilleros es igual a tamano $\land$\\
    La longitud del vector m.casilleros es igual a la de todo otro vector dentro de el) $\land$\\
    Es conexa % Trivial
  }
  
  \mbox{}

  \Abs[mapa]{hab}[m]{h}{$m.tamano$ $\igobs$ $tam(h)$ $\yluego$\\
    ($\forall t$: tuple(nat,nat))($0 \leq$ $\Pi_1(t)$, $\Pi_2(t) < m.tamano - 1$ $\impluego$\\
    libre(m, t) $\igobs$ $m.casilleros[\Pi_1(t)][\Pi_2(t)]$)}

\end{Representacion}

\bigskip

\begin{Algoritmos}

En esta sección se hace abuso de notación en los cálculos de álgebra de órdenes presentes en la justificaciones de los algoritmos. La operación de suma ``+'' denota secuencialización de operaciones con determinado orden de complejidad, y el símbolo de igualdad ``='' denota la pertenencia al orden de complejidad resultante.

\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iTam}(\In{m}{mapa}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
       \State $res \gets m.tamano$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
\end{Algoritmos}

\newpage


\section{Módulo Mapa}

Aqui va la descripción

\begin{Interfaz}
  
  \textbf{generos}: \TipoVariable{mapa}.

  \textbf{se explica con}: \tadNombre{Habitación}.

  \Titulo{Operaciones básicas del mapa}
  \InterfazFuncion{nuevoMapa}{\In{n}{nat}}{mapa}%
  {$res \igobs nuevaHab(n)$}%
  [$\Theta(n^2)$]
  [genera un mapa de tamano n x n.]

  \InterfazFuncion{ocupar}{\Inout{m}{mapa}, \In{c}{$tupla(int, int)$}}{}%
  [$m \igobs m_0$ $\land$ $c \in casilleros(m)$ $\yluego$ $libre(m, c)$ $\land$ $alcanzan(libres(m)-c, libres(m)-c, m)$]
  %lo de m = m0 es igualdad observacional, no?
  {$m$ $\igobs$ $ocupar(c,m_0)$}%
  [$\Theta(1)$]
  [ocupa una posicion del mapa siempre y cuando este no deje de ser conexo.]

  \InterfazFuncion{tam}{\In{m}{mapa}}{nat}%
  {$res$ $\igobs$ $tam(m)$}%
  [$\Theta(1)$]
  [devuelve el tamano del mapa.]
    
  \InterfazFuncion{libre}{\In{m}{mapa}, \In{c}{$tupla(int, int)$}}{bool}%
  [$c \in casilleros(m)$]%
  {$res$ $\igobs$ $libre(c, m)$}
  [$\Theta(1)$]
  [devuelve si un elemento esta ocupado.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación del mapa}

  El objetivo de este módulo es implementar una lista doblemente enlazada con punteros al principio y al fin.  Para simplificar un poco el manejo de la estructura, vamos a reemplazarla por una lista circular, donde el siguiente del último apunta al primero y el anterior del primero apunta al último.  La estructura de representación, su invariante de representación y su función de abstracción son las siguientes.

  \begin{Estructura}{mapa}[m]
    \begin{Tupla}[m]
      \tupItem{tamano}{nat}%
      \tupItem{casilleros}{vec(vec(bool))}%
    \end{Tupla}
  \end{Estructura}

  \Rep[mapa][m]{
    La longitud de m.casilleros es igual a tamano $\land$\\
    La longitud del vector m.casilleros es igual a la de todo otro vector dentro de el) $\land$\\
    Es conexa % Trivial
  }\mbox{}

  \Abs[mapa]{hab}[m]{h}{$m.tamano$ $\igobs$ $tam(h)$ $\yluego$\\
    ($\forall t$: tuple(nat,nat))($0 \leq$ $\Pi_1(t)$, $\Pi_2(t) < m.tamano - 1$ $\impluego$\\
    libre(m, t) $\igobs$ $m.casilleros[\Pi_1(t)][\Pi_2(t)]$)}

\end{Representacion}

\bigskip

\begin{Algoritmos}

En esta sección se hace abuso de notación en los cálculos de álgebra de órdenes presentes en la justificaciones de los algoritmos. La operación de suma ``+'' denota secuencialización de operaciones con determinado orden de complejidad, y el símbolo de igualdad ``='' denota la pertenencia al orden de complejidad resultante.

\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iTam}(\In{m}{mapa}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
       \State $res \gets m.tamano$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iOcupar}(\Inout{m}{mapa}, \In{c}{tupla(int, int)})}
  \begin{algorithmic}[1]
			 \State $m[\Pi_1(c)][\Pi_2(c)] \gets true$ 				\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} El acceso a una posición de un vector y su modificación es $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iLibre}(\In{m}{mapa}, \In{c}{tupla(int, int)}) $\to$ $res$ : bool}
	\begin{algorithmic}[1]
			 \State $res \gets \neg \ m[\Pi_1(c)][\Pi_2(c)]$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:} El acceso a una posición de un vector es $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	

\begin{algorithm}[H]{\textbf{iNuevoMapa}(\In{n}{nat}) $\to$ $res$ : $mapa$}
  \begin{algorithmic}[1]
      \State $m.tamano \gets n$                   \Comment $\Theta(1)$
      \State $v \gets Vacia()$	                  \Comment $\Theta(1)$
      \State $i \gets 0$                          \Comment $\Theta(1)$
      \While{$i < n$}                             \Comment $O(n)$
        \State $v.AgregarAtras(false)$
        \State $i \gets i + 1$
      \EndWhile
      \State $i \gets 0$
      \While{$i < n$}                             \Comment $O(n^2)$
        \State $res.AgregarAtras(v.Copiar())$     \Comment $O(n)$
        \State $i \gets i + 1$                    \Comment $O(1)$
      \EndWhile
      \medskip
      \Statex \underline{Complejidad:} $\Theta(n^2)$
      \Statex \underline{Justificación:} Copiar un vector de n booleanos es $O(n * copy(bool))$ y copiar un bool es $\Theta(1)$. Luego, agregar n veces la copia del vector es $O(n^2)$
    	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\newpage

\end{document}
