% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a página completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Cátedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={Módulos básicos},
 pdftitle={Módulos básicos de diseño},
 pdfsubject={Módulos básicos de diseño}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$1^\mathrm{er}$ cuatrimestre de 2019}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Apunte de Módulos Básicos (v.\ 0.3$\alpha$)}
\author{Algoritmos y Estructuras de Datos II, DC, UBA.}
\date{\Cuatrimestre}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{\Cuatrimestre}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}
\newcommand{\ttab}{\tab \tab}
\newcommand{\tttab}{\tab \tab \tab}
\newcommand{\ttttab}{\tab \tab \tab \tab}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \emph{#2}: \TipoVariable{#3},%
}
\newcommandx{\tupItemF}[3][1={\ }]{%
    %\hspace*{3mm}%
    \emph{#2}: \TipoVariable{#3}%
}

\newcommandx{\Comentario}[1]{
  // #1\\
}

%\newcommandx{\tupItem}[3][1={\ }]{%
%    %\hspace*{3mm}%
%    \ifthenelse{\boolean{EstructuraHayItems}}{%
%        ,#1%
%    }{}%
%    \emph{#2}: \TipoVariable{#3}%
%    \setboolean{EstructuraHayItems}{true}%
%}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}
\newcommand{\BigO}{\ensuremath{\mathcal{O}}}
\newcommand{\tuple}[1]{\langle #1 \rangle}

\begin{document}

%pagina de titulo
\thispagestyle{empty}
\maketitle
\tableofcontents

\newpage

\section{Introducción}

    A lo largo del TP, hacemos los siguientes reemplazos sintácticos:



    - $jugador$ es un $string$

    - $fantasma$ es un $vector(evento)$

    - $pos$ es $\tuple{x: nat, y: nat}$

    - $evento$ es $\tuple{pos: \textbf{pos},\ dir: \textbf{dir},\ dispara?: \textbf{bool}}$

    - $pasoDisparos$ es $\tuple{pasoDispFan: nat,\ pasoDispPJ: nat}$

\newpage

\section{Diccionario Trie ($\alpha$)}

  \noindent{El módulo Diccionario Trie provee un diccionario básico montado sobre un trie.\\
  Solo se definen e implementan las operaciones que serán utilizadas.

  \begin{Interfaz}

    \textbf{parámetros formales}\hangindent=2\parindent\\
    \parbox{1.7cm}{\textbf{géneros}}$\alpha$\\
    \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{.5\textwidth-\parindent-1.7cm}{%
      \InterfazFuncion{Copiar}{\In{s}{$\alpha$}}{$\alpha$}
      {$res \igobs s$}
      [$\Theta(copy(s))$]
      [función de copia de $\alpha$]
    }

    \textbf{se explica con}: \tadNombre{Diccionario$(string, \alpha)$}.

    \textbf{géneros}: \TipoVariable{diccTrie$(string, \alpha)$}.

    \Titulo{Operaciones básicas de diccionario}

    \InterfazFuncion{Vacío}{}{diccTrie$(string, \alpha)$}%
    {$res$ $\igobs$ vacio}%
    [$\Theta(1)$]
    [genera un diccionario vacío.]

    \InterfazFuncion{Definir}{\Inout{d}{diccTrie($string$, $\alpha$)}, \In{k}{$string$}, \In{s}{$\alpha$}}{$\alpha$}
    [$d \igobs d_0$]
    {$d$ $\igobs$ definir($d, k, s$)}
    [$\Theta(|k| + copy(s))$]
    [define la clave $k$ con el significado $s$ en el diccionario.]
    [los elemnetos $k$ y $s$ se definen por copia.]

    \InterfazFuncion{Definido?}{\In{d}{diccTrie($string$, $\alpha$)}, \In{k}{$string$}}{bool}
    {$res$ $\igobs$ def?($d$, $k$)}
    [$\BigO(|k|)$]
    [devuelve \texttt{true} si $k$ está definido en el diccionario.]

    \InterfazFuncion{Significado}{\In{d}{diccTrie($string$, $\alpha$)}, \In{k}{$string$}}{$\alpha$}
    [def?($d$, $k$)]
    {alias($res$ $\igobs$ obtener($d$, $k$))}
    [$\Theta(|k|)$]
    [devuelve el significado de la clave $k$ en $d$.]
    [$res$ es modificable si y sólo si $d$ es modificable.]


    \InterfazFuncion{Claves}{\In{d}{diccTrie($string$, $\alpha$)}}{conj(string)}
    {$res$ $\igobs$ claves($d$)}
    [$\Theta(1)$]
    [devuelve las claves definidas en el diccionario]

  \end{Interfaz}

  \begin{Representacion}
    
    \Titulo{Representación del diccionario}
    \begin{Estructura}{diccTrie$(string, \alpha)$}[dic]

      \begin{Tupla}[dic]%
        \tupItemF{raiz}{puntero(nodo)},\\
        \tupItemF{claves}{conj(string)}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[nodo]
        \tupItem{significado}{puntero($\alpha$)}\\
        \tupItemF{siguientes}{arreglo(puntero(nodo))[256]}
      \end{Tupla}

    \end{Estructura}

    \Rep[dic][d]{\\
      (Los nodos del diccionario (excepto la raiz) tienen un unico padre. Es decir, no hay dos Nodos en la estructura que tengan punteros iguales en los siguientes del Nodo. $\land$\\
      La raiz no tiene padre. Es decir, no hay un camino de hijos por el cual se llegue a dicho Nodo. $\land$\\
      Todas las hojas tienen un significado distinto de NULL. $\land$ \\
      Un s string pertenece a d.claves $\iff$ estáDefinido(s, d.claves)) \\ \\
      // La primer condicion implica que no hay ciclos ni Nodos con hijos de menor nivel\\
    }

    ~

    \Abs[dic]{dicc($string$, $\alpha$)}[e]{d}{ \\
    (\paratodo s : string)(def?(s,d) $\igobs$ estáDefinido(e.raiz, s)) $\land$ \\
    (\paratodo s : string)(def?(s,d) $\impluego$ obtener(s, d) $\igobs$ significado(e.raiz, s)) $\land$ \\
    claves(d) $\igobs$ e.claves}\\ 
  
  estáDefinido(r, s) $\equiv$ 
  \textbf{if} vacia?(s) \\
  \ttab \textbf{then} r $\DRef$ significado $\neq$ NULL \\ 
  \ttab \textbf{else} r $\DRef$ sigueintes[int(prim(s))] $\neq$ NULL $\yluego$ estáDefinido(r.siguientes[int(prim(s))], fin(s)) 
  \textbf{fi} \\

  significado(r,s)  $\equiv$ 
  \textbf{if} vacia?(s) \\
  \ttab \textbf{then} r $\DRef$ significado \\ 
  \ttab \textbf{else} significado(r.siguientes[int(prim(s))], fin(s)) 
  \textbf{fi} \\

\end{Representacion}


\begin{Algoritmos}

    \begin{algorithm}[H]{\textbf{iVacía}() $\to$ $res$ : \&dic}
      \begin{algorithmic}[1]
           \State // Le asigna un nuevo nodo a la raiz
           \State $res \gets \tuple{raiz: nuevoNodo()}$				\Comment $\Theta(1)$
    
          \medskip
          \Statex \underline{Complejidad:} $\Theta(1)$
          \Statex \underline{Justificación:} La complejidad de crear un nuevo nodo es $\Theta(1)$
          \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iSignificado}(\Inout{d}{dic}, \In{k}{$string$})$\to$ $res$ : \&$\alpha$}
      \begin{algorithmic}[1]
        \State $Nodo \ actual \gets d.raiz$                                                      \Comment $\Theta(1)$

        \State $\textbf{for} \ (char \ c \ : \ k) \ \ \textbf{do}$                               \Comment $\BigO(|k|)$  
        \State \tab $actual \gets (actual \DRef siguientes [toInt(c)])$       \Comment $\Theta(1)$
        \State $\textbf{end for}$                                    

        \State $res \gets *(actual \DRef significado)$                                          \Comment $\Theta(1)$

          \medskip
          \Statex \underline{Complejidad:} $\Theta(|k|)$
          \Statex \underline{Justificación:} Los accesos y las asignaciones de punteros son $\Theta(1)$. Como el ciclo se ejecuta |k| veces, se ejecutaran dichas asignaciones |k| veces. Luego la complejidad será $\Theta(|k|)$.
          \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iClaves}(\In{d}{dic})$\to$ $res$ : conj(string)}
      \begin{algorithmic}[1]
        \State $res \gets e.claves$                                            \Comment $\Theta(1)$
  
          \medskip
          \Statex \underline{Complejidad:} $\Theta(1)$
          \Statex \underline{Justificación:} Devolver por referencia un conjunto es $\Theta(1)$.
          \end{algorithmic}
    \end{algorithm}
  


    \begin{algorithm}[H]{\textbf{iDefinido?}(\Inout{d}{dic}, \In{k}{$string$}) $\to$ $res$ : bool}
      \begin{algorithmic}[1]
        \State $Nodo \ actual \gets d.raiz$                                                      \Comment $\Theta(1)$

        \State $\textbf{for} \ (char \ c \ : \ k) \ \ \textbf{do}$                               \Comment $\BigO(|k|)$  
        \State \tab  $\textbf{if} \ (actual \DRef siguientes [toInt(c)] \ \neq  \ NULL) $        \Comment $\Theta(1)$
        \State \ttab   $\textbf{then} \ actual \gets (actual \DRef siguientes [toInt(c)])$       \Comment $\Theta(1)$
        \State \ttab  $\textbf{else} \ res \gets false$                                           \Comment $\Theta(1)$
        \State \tab $\textbf{end if}$
        \State $\textbf{end for}$                                    

        \State $res \gets ((actual \DRef significado) \neq NULL)$                                                                  \Comment $\Theta(1)$

          \medskip
          \Statex \underline{Complejidad:} $\BigO(|k|)$
          \Statex \underline{Justificación:} Los accesos y las asignaciones de punteros son $\Theta(1)$. Como el ciclo se ejecuta a lo sumo |k| veces, se ejecutaran dichas asignaciones |k| veces como máximo. Luego la complejidad será $\BigO(|k|)$.
          \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iDefinir}(\Inout{d}{dic}, \In{k}{$string$}, \In{s}{$\alpha$}) $\to$ $res$ : $\&\alpha$}
      \begin{algorithmic}[1]
          \State $Nodo \ actual \gets d.raiz$
          \State $\textbf{for} \ (char \ c \ : \ k) \ \ \textbf{do}$                                          \Comment $\Theta(|k|)$  
          \State \tab   // Si no tengo siguiente, lo creo
          \State \tab   $\textbf{if} \ (actual \DRef siguientes [toInt(c)] \ == \ NULL) \ \ \textbf{then}$    \Comment $\Theta(1)$
          \State \ttab  $\ actual \DRef siguientes[toInt(c)] = nuevoNodo()$                                   \Comment $\Theta(1)$
          \State \tab   $\textbf{end if}$
          \State \tab   $actual \gets (actual \DRef siguientes [toInt(c)])$                                   \Comment $\Theta(1)$
          \State $\textbf{end for}$  
          \State
          \State // Estoy parado en el nodo que va a tener el puntero al significado.
          \State // Reservo un lugar en memoria y hago una copia del provisto en dicho lugar.
          \State $sig \gets s$                                                                                \Comment $\Theta(copy(s))$
         
       \\ \State // Si el significado no está definido, agrego la nueva clave al conjunto de claves 
          \State $\textbf{if} \ (actual \DRef significado \ == \ NULL) \ \ \textbf{then}$    \Comment $\Theta(1)$
          \State // Como precondición se que no existe así que la agrego rápido
          \State AgregarRapido(e.claves, k)                                                                   \Comment $\Theta(copy(k))$
          \State $\textbf{end if}$

       \\ \State // Asigno al significado del nodo el puntero creado con s y libero la memoria que contenía al valor anterior.
          \State $(actual \DRef significado) \gets \&sig$                                                     \Comment $\Theta(1)$


      \\  \State // Devuelvo por referencia el significado.
          \State res $\gets sig$

          \medskip
          \Statex \underline{Complejidad:} $\Theta(|k| + copy(s))$
          \Statex \underline{Justificación:} Siempre se recorre toda la palabra para definirla, entonces el $for$ siempre tiene $|k|$ ciclos. La dereferenciación y comparación de punteros, e indexación en arreglos estáticos son $\Theta(1)$.
          \end{algorithmic}
    \end{algorithm}
  
    \begin{algorithm}[H]{\textbf{inuevoNodo}() $\to$ $res$ : puntero(nodo)} \Comment Función privada que crea un nuevo nodo
      \begin{algorithmic}[1]
        \State // Reserva la memoria para un nuevo nodo con significado null y siguientes vacios
        \State $res \gets \& \tuple{significado: NULL, \ siguientes: arreglo\_estatico[256] \ de\ puntero(Nodo)}$ 				\Comment $\Theta(1)$
 
          \medskip
          \Statex \underline{Complejidad:} $\Theta(1)$
          \Statex \underline{Justificación:} El tiempo de creación de un array de 255 posiciones es $\BigO(255) \in \BigO(1)$
          \end{algorithmic}
    \end{algorithm}
  \end{Algoritmos}

\newpage

\section{Módulo Juego}

  Aqui va la descripción

  \begin{Interfaz}
    \textbf{generos}: \TipoVariable{juego}.

    \textbf{se explica con}: \tadNombre{Juego}.

    \Titulo{Operaciones básicas de Juego}
    
    // Generador

    $\bullet$ \InterfazFuncion{iniciar}{\In{m}{mapa}, \In{pjs}{conj(jugador)}, \In{eventosFan}{vector(evento))}}{juego}%
    [$\neg vacio(pjs) \land \neg vacio(f) \land (\forall e: evento) (esta?(e,\ eventosFan) \impluego e.pos \in libres(m))$]
    {$res \igobs nuevoJuego(m, pjs, eventosFan)$}%
    [$\Theta(m^2 + \#pjs*|pjMasLargo| + locJugadores + long(eventosFan)^2)$]
    [crea un nuevo juego con el mapa dado, un conjunto de jugadores, y los eventos de un fantasma.]

    // Operaciones pedidas

    $\bullet$ \InterfazFuncion{infoActualPjVivos}{\In{j}{Juego}}{conj(Tupla(jugador, pos, dir))}%
    {res $\igobs$ infoActualPjVivos(j)}%
    [$\Theta(1)$]
    [devuelve un conjunto referencias a identidad, posicion y direccion actual de los jugadores vivos.]

    $\bullet$ \InterfazFuncion{infoActualFanVivos}{\In{j}{Juego}}{conj(Tupla(pos, dir))}%
    {$res \igobs infoActualFanVivos(j)$}%
    [$\Theta(1)$]
    [devuelve un conjunto referencias a la información de los fantasmas que están vivos.]

    $\bullet$ \InterfazFuncion{infoActualFanEspecial}{\In{j}{Juego}}{Tupla(pos, dir)}%
    {$res \igobs infoActualFanEspecial(j)$}%
    [$\Theta(1)$]
    [devuelve la posicion y direccion del fantasma especial.]

    $\bullet$ \InterfazFuncion{infoActualFanVivosQueDisp}{\In{j}{Juego}}{conj(Tupla(pos, dir))}%
    {$res \igobs infoActualFanVivosQueDisp(j)$}%
    [$\BigO(\#fv)$]
    [devuelve un conjunto con la información de los fantasmas que están vivos y disparan en el ultimo paso ejecutado en el juego.]

    $\bullet$ \InterfazFuncion{vivo?}{\In{j}{juego}, \In{pj}{string}}{bool}
    [$pj \in jugadores(j)$]
    {$res \igobs jugadorVivo(pj, j)$}
    [$\BigO(|pj|)$]
    [devuelve si un jugador está vivo]

    $\bullet$ \InterfazFuncion{ejecutarAccion}{\Inout{j}{juego}, \In{a}{accion}, \In{pj}{jugador}}{}%
    [$j \igobs j_0 \yluego pj \in jugadores(j) \yluego jugadorVivo(pj, j) \land \neg esPasar(a)$]
    {$j \igobs step(j_0, a, pj)$}%
    [$\BigO(|j| + \#fv * m + \#jv)$]
    [actualiza con la acción $a$ del jugador $pj$.]

    $\bullet$ \InterfazFuncion{pasarTiempo}{\Inout{j}{juego}}{}%
    {$j \igobs pasar(j_0)$}%
    [$\BigO(\#fv * m + \#jv)$]
    [actualiza sin acción de jugador.]

    $\bullet$ \InterfazFuncion{posOcupadasPorDisparosFan}{\In{j}{juego}}{conj(posicion)}
    {$res \igobs alcanceDisparosFantasmas(fantasmas(j), j)$}
    [$\Theta(1)$]
    [devuelve un conjunto de las posiciones afectadas por disparos de fantasmas enl último paso.]

    // Observadores del TAD

    \InterfazFuncion{habitacion}{\In{j}{juego}}{mapa}%
    {$res \igobs habitacion(j)$}%
    [$\Theta(1)$]
    [devuelve la habitacion del juego]

    \InterfazFuncion{fantasmas}{\In{j}{juego}}{conj(fantasma)}%
    {$res \igobs fantasmas(j)$}%
    [$\Theta(\#fantasmas(j))$]
    [devuelve por referencia un conjunto de todos los fantasmas del juego]
    [res es no modificable]

    \InterfazFuncion{fantasmaEspecial}{\In{j}{juego}}{fantasma}%
    {$res \igobs fantasmaEspecial(j)$}%
    [$\Theta(1)$]
    [devuelve por referencia un conjunto de todos los fantasmas del juego]
    [res es no modificable]

    \InterfazFuncion{jugadores}{\In{j}{juego}}{conj(jugadores)}%
    {$res \igobs jugadores(j)$}%
    [$\Theta(\#jugadores(j))$]
    [devuelve por referencia un conjunto de todos los jugadores del juego]
    [res es no modificable]

    \InterfazFuncion{acciones}{\In{pj}{jugador}, \In{j}{juego}}{secu(evt)}%
    {$res \igobs acciones(pj, j)$}%
    [$\Theta(|j|)$]
    [devuelve por referencia un conjunto de todos los jugadores del juego]
    [res es no modificable]

    \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}

    \begin{tad}{Juego Extendido($\alpha$)}
      \parskip=0pt
    
      \tadOtrasOperaciones
      \tadOperacion{infoActualPjVivos}{Juego}{conj(Tupla(jugador, posicion, direccion))}{}
      \tadOperacion{infoActualPjVivosAux}{Juego, conj(jugador)}{conj(Tupla(jugador, posicion, direccion))}{}
      \tadOperacion{infoActualFanVivos}{Juego}{conj(Tupla(posicion, direccion))}{}
      \tadOperacion{infoActualFanVivosAux}{Juego, conj(fantasma)}{conj(Tupla(posicion, direccion)}{}
      \tadOperacion{infoActualFanEspecial}{Juego}{Tupla(posicion, direccion)}{}
      \tadOperacion{infoActualFanVivosQueDisp}{Juego}{conj(Tupla(posicion, direccion))}{}
      \tadOperacion{infoActualFanVivosQueDisAux}{Juego, conj(fantasmas)}{conj(Tupla(posicion, direccion))}{}
      
      \tadAxiomas
      \tadAxioma{infoActualPjVivos($j$)}{infoActualPjVivosAux(j, jugadores(j))}
      \tadAxioma{infoActualPjVivosAux($j, js$)}{\IF jugadorVivo(dameuno(js), j) THEN Ag($\tuple{posJugador(dameuno(js), j), dirJugador(dameuno(js),\ j)}$, \\infoActualPjVivosAux(j, sinuno(js))) 
      ELSE infoActualPjVivosAux(j, sinuno(js)) 
      FI}
      \tadAxioma{infoActualFanVivos($j$)}{infoActualPjVivosAux(j, jugadores(j)}
      \tadAxioma{infoActualFanVivosAux($j, fs$)}{\IF fantasmaVivo(dameuno(fs), j) THEN Ag($\tuple{posFantasma(dameuno(fs), j), dirFantasma(dameuno(fs),\ j)}$, \\infoActualFanVivosAux(j, sinuno(fs))) 
      ELSE infoActualFanVivosAux(j, sinuno(fs)) 
      FI}
      \tadAxioma{infoActualFanEspecial($j$)}{$\tuple{posFantasma(fantasmaEspecial(j), j), \ dirFantasma(fantasmaEspecial(j), j)}$}
      \tadAxioma{infoActualFanVivosQueDisp($j$)}{infoActualFanVivosAux(j, infoActualFanVivosQueDisAux(j, fantasmas(j)))}
      \tadAxioma{infoActualFanVivosQueDispAux($j, fs$)}{\IF fantasmaVivo(dameuno(fs), j) $\land$ disparando(dameuno(fs), step(j))  
      THEN Ag(dameuno(fs), infoActualFanVivosQueDispAux(j, sinuno(fs)))
      ELSE infoActualFanVivosQueDispAux(j, sinuno(fs)) FI}

    \end{tad}
  \end{Interfaz}

  \begin{Representacion}
    
    \Titulo{Representación de Juego}
    \begin{Estructura}{juego}[estr]
      \begin{Tupla}[j]
        \Comentario{General}
        \tupItem{paso}{nat}\\
        \tupItem{ronda}{nat}\\
        \tupItem{mapa}{Mapa}\\

        \Comentario{Disparos}
        \tupItem{mapaDisparos}{arreglo(arreglo(pasoDisparos))}\\
        \tupItem{disparosFanUltimoPaso}{conj(posicion)}\\

        \Comentario{Jugadores}
        \tupItem{infoJugadores}{diccTrie(string, infoPJ)}\\
        \tupItem{infoActualJugadoresVivos}{conj(infoActualPJ)}\\
        \tupItem{infoJugadoresVivos}{conj(puntero(infoPJ))}\\

        \Comentario{Fantasmas}
        \tupItem{infoFantasmas}{conj(infoFan)}\\
        \tupItem{infoActualFantasmasVivos}{conj(infoActualFan)}\\
        \tupItem{infoFantasmasVivos}{conj(itConj(infoFan))}\\
        \tupItemF{infoFantasmaEspecial}{itConj(infoActualFan)}
      \end{Tupla}
      
      \mbox{}

      \begin{Tupla}[infoPJ]
        \tupItem{eventos}{lista(evento)}\\
        \tupItem{vivo?}{bool}\\
        % Solo cuando está vivo
        \tupItemF{infoActual}{itConj(infoActualPJ)}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[infoActualPJ]
        \tupItem{identidad}{string}\\
        \tupItem{posicion}{pos}\\
        \tupItemF{direccion}{dir}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[infoFan]
        \tupItem{eventos}{vector(evento)}\\
        \tupItem{vivo?}{bool}\\
        % Solo cuando está vivo
        \tupItemF{infoActual}{itConj(infoActualFan)}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[infoActualFan]
        \tupItem{posicion}{pos}\\
        \tupItemF{direccion}{dir}
      \end{Tupla}

    \end{Estructura}

    \Rep[estr][e]{\\
      $(\forall\ t: tupla)(t \in e.mapaDisparos \impluego \Pi_1(p),\ \Pi_2(p) \leq e.paso)$ $\land$\\
      $(\forall\ p: pos)(p \in e.disparosFanUltimoPaso \iff mapaDisp[pos.x][pos.y].pasoDispFan = paso)$ $\land$ \\ \\
      $(\forall\ ip: infoPJ)(ip \in valores(e.infoJugadores) \impluego (long(ip.eventos) \leq paso \land (ip.vivo? \impluego long(ip.eventos = paso) \land (ip.vivo? \iff$ no estuvo en las posiciones afectadas por los disparos de los fantasmas en los pasos anteriores.) $\land$ todas las posiciones de los eventos son posiciones libres en e.mapa $\land$ no hay saltos de posiciones entre 2 eventos consecutivos.$\land$  el cambio de posición entre un evento de if.eventos y su consecutivo debe ser el correspondiente al cambio de dirección entre ellos, considerando también la libertad de la posición en e.mapa)) $\land$\\ \\
      $(\forall\ if: infoFan)(if \in e.infoFantasmas \impluego (e.vivo? \iff$ no estuvo en las pos afectadas por los disparos de los jugadorse en los pasos anteriores.) $\land$ todas las posiciones de if.eventos son posiciones libres en e.mapa $\land$ no hay saltos de posiciones entre 2 eventos consecutivos en if.eventos $\land$ el cambio de posición entre un evento de if.eventos y su consecutivo debe ser el correspondiente al cambio de dirección entre ellos, considerando también la libertad de la posición en e.mapa) $\land$ \\ \\
      $(\forall\ iaf: infoActualFan)(iaf \in e.infoActualFantasmasVivos \impluego$  la posición y dirección son las del evento correspondiente a la posición de la secuencia definida por paso mód long(eventos del fantasma)) $\land$ \\ \\
      $\#e.infoFantasmas = ronda + 1$ $\land$ \\
      Los tamaños de e.mapa y e.mapaDisparos son \textbf{exactamente} iguales. $\land$ \\
      $\neg(\exists p: pos)$(Es válida y está ocupada en e.mapa y tiene disparos en e.mapaDisparos) $\land$ \\
      Una posición en e.mapaDisparos tiene un disparo de un personaje en un paso en particular $\iff$ un personaje disparó ese paso y no hubo disparos posteriores a ese paso efectuados por personajes. $\land$ \\ \\
      Una posición en e.mapaDisparos tiene un disparo de un fantasma en un paso en particular $\iff$ un fantasma disparó ese paso y no hubo disparos posteriores a ese paso efectuados por fantasmas. $\land$ \\ \\
      Si un personaje o fantasma dispara desde una $pos$ hacia una $dir$, en el mapa disparos debe haber una linea recta desde esa pos hacia esa dir hasta el fin del mapa o una posicion ocupada con valores mayores o iguales al paso en el que se efectuó $\land$\\ \\
      Una infoPJ  se corresponde con su infoActual $\iff$ (está vivo $\land$  la posición y la dirección son iguales a las de su último evento $\land$ su identidad es la clave que obtiene dicha infoPJ en e.infoJugadores) $\land$ \\
      $(\forall\ iapj: infoActualPJ)(iapj \in e.infoActualJugadoresVivos \iff$ su correspondiente infoPJ está vivo) $\land$ \\
      $(\forall\ ip: puntero(infoPJ))(ip \in e.infoJugadoresVivos \iff ip \DRef vivo?)$ $\land$ \\
      \#e.infoActualJugadoresVivos = \#e.infoJugadoresVivos $\land$ \\ \\
      $(\forall\ if: infoFan)(if \in e.infoFantasmas \impluego (\exists\ n:nat)(long(if.eventos) = n*2+5$ $\yluego$ (los últimos n eventos de if.eventos son los primeros n invertidos $\land$ los eventos entre n y n+5 son pasar))) $\land$ \\
      Una infoFan  se corresponde con su infoActual $\iff$ (está vivo $\land$  la posición y la dirección son iguales a las de su último evento efectuado) $\land$ \\
      $(\forall\ iaf: infoActualFan)(iaf \in e.infoActualFanVivos \iff$ su correspondiente infoFan está vivo) $\land$ \\
      $(\forall\ if: infoFan))(if \in e.infoFantasmasVivos \iff if.vivo?)$ $\land$ \\
      \#e.infoActualFantasmasVivos = \#e.infoFantasmasVivos $\land$ \\
      El fantasma especial siempre está vivo.
      }
    \newpage
    \mbox{}
    \Abs[estr]{Juego}[e]{j}{$e.mapa \igobs habitacion(j)$ $\land$ \\
    $claves(e.infoJugadores) \igobs jugadores(j)$ $\yluego$ \\
    $(\forall \ pj: jugador)(pj \in jugadores(j) \impluego acciones(pj,\ j) \igobs obtener(pj, e.infoJugadores).eventos)$ $\land$ \\
    $fantasmas(j) \igobs tomarSubsec(infoFantasmas.eventos,\ 0,\ long(fantasmas(j)))$ $\land$ \\
    $(\exists \ if: infoFan)(if \in e.infoFantasmas$ $\land$ $if.infoActual \igobs e.infoFantasmaEspecial \yluego\\ if.eventos \igobs fantasmaEspecial(j))$}
  \end{Representacion}

  \bigskip

  \begin{Algoritmos}

  \medskip
    
  \Titulo{Algoritmos del módulo}
      \medskip
    
  \begin{algorithm}[H]{\textbf{iIniciar}(\In{m}{mapa}, \In{pjs}{conj(jugador)}, \In{eventosFan}{vector(evento)}) $\to$ $res$ : estr}
        \begin{algorithmic}[1]
        \State // Inicializo la estructura
        \State $res: \langle$
        \State \tab // Inicializo contadores
        \State \tab $paso : 0,$                     \Comment $\Theta(1)$
        \State \tab $ronda : 0,$                     \Comment $\Theta(1)$
        \\
        \State \tab // Seteo el mapa 
        \State \tab $mapa: m,$                     \Comment $\Theta(Tam(m)^2)$
        \\
        \State \tab // Inicializo el mapa de disparos con el mismo tamaño que el mapa
        \State \tab $mapaDisparos: arreglo(arreglo(tupla(nat, nat))[Tam(m)])[Tam(m)],$ \Comment $\Theta(Tam(m)^2)$
        \State \tab $disparosFanUltimoPaso: Vacio(),$ \Comment $\Theta(1)$
        \\
        \State \tab /a/ Inicializo estructuras de jugadores y fantasmas como vacías
        \State \tab $infoActualJugadoresVivos: Vacio(),$  \Comment $\Theta(1)$
        \State \tab $infoJugadoresVivos: Vacio(),$ \Comment $\Theta(1)$
        \State \tab $infoJugadores: Vacia(),$ \Comment $\Theta(1)$
        \State \tab $infoFantasmas: Vacio(),$ \Comment $\Theta(1)$
        \State \tab $infoActualFantasmasVivos: Vacio(),$ \Comment $\Theta(1)$
        \State \tab $infoFantasmasVivos: Vacia(),$ \Comment $\Theta(1)$
        \State \tab $infoFantasmaEspecial: CrearIt(Vacio())$ \Comment $\Theta(1)$
        \State $\rangle$
        \\
        \State // Inicializo los jugadores
        \State $iIniciarJugadores(res,\ m,\ pjs)$ \Comment $\Theta(\#pjs*|pjMasLargo| + locJugadores)$
        \\
        \State // Creo el nuevo fantasma
        \State $iNuevoFanEspecial(res,\ eventosFan)$ \Comment $\Theta(long(eventosFan)^2)$
        \medskip
        \Statex \underline{Complejidad:} $\Theta(m^2 + \#pjs*|pjMasLargo| + locJugadores + long(eventosFan)^2)$
        \Statex \underline{Justificación:} Copiar y generar iteradores, tuplas y conjuntos es $\Theta(1)$.
        \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iIniciarJugadores}(\Inout{j}{estr}, \In{m}{mapa}, \In{pjs}{conj(jugador)})} \Comment Función privada
    \begin{algorithmic}[1]
      \State // Pre: pjs no es vacio
      \State // Post: se inicializan las estructuras de los jugadores
      \\
      \State // Suponemos la existencia de la función
      \State // $dict(jugador,\ tupla(pos, dir))\ localizarJugadores(m,\ pjs)$ 
      \\
      \State // Obtengo las posiciones y direcciones de jugadores
      \State $localPJs \gets localizarJugadores(m,\ pjs)$ \                                                               \Comment $\Theta(locJugadores)$
      \\
      \State // Lleno las estructuras de jugadores
      \State $\textbf{for} \ (pj,\ localizacion : \ localPJs) \ \ \textbf{do}$                                            \Comment $\BigO(\#pjs*(|pjMasLargo|+copy(infoMasGrande)))$
      \State \tab // Creo la infoActual y la agrego a su conjunto
      \State \tab $infoActual \gets \tuple{identidad: pj,\ posicion: localizacion.pos,\ direccion: localizacion.dir}$     \Comment $\Theta(1)$
      \State \tab $itInfoActual \gets AgregarRapido(j.infoActualJugadoresVivos,\ infoActual)$                             \Comment $\Theta(copy(infoActual))$
      \\
      \State \tab // Creo la infoPJ con la actual
      \State \tab $info \gets iNuevaInfoPJ(localizacion,\ itInfoActual)$                                                  \Comment $\Theta(1)$
      \State \tab // La agrego al trie y me guardo el puntero a la info guardada
      \State \tab $infoPtr \gets \& Definir(j.infoJugadores,\ pj,\ info)$                                                 \Comment $\Theta(|pj|+copy(info))$
      \\
      \State \tab // Agrego al conjunto de jugadores vivos el puntero a la info del PJ
      \State \tab $AgregarRapido(j.infoJugadoresVivos,\ infoPtr)$                                                         \Comment $\Theta(copy(infoActual))$
      \State $\textbf{end for}$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(\#pjs*|pjMasLargo| + locJugadores)$
      \Statex \underline{Justificación:} Copiar y generar iteradores, tuplas y conjuntos es $\Theta(1)$. Definir es $\Theta(|pj|)$ ya que copiar la tupla de info es $\Theta(1)$. Luego, definir \#pjs es $\BigO(\#pjs*|pjMasLargo|)$. Finalmente, la complejidad de todo el algoritmo es $\BigO(\#pjs*|pjMasLargo| + locJugadores)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iNuevaInfoPJ}(\In{localizacion}{tupla(pos, dir), \In{itInfoActual}{itConj(infoActualPJ)}}) $\to res:$ infoPJ} \Comment Función privada
    \begin{algorithmic}[1]
      \State // Pre: el iterador es valido
      \State // Post: se genera la info pj con el iterador y los datos

      \State // Armo la infoPJ
      \State $res \gets \langle$                    \Comment $\Theta(1)$
      \State \tab $eventos: iCrearEventosConLocalizacion(localizacion)$
      \State \tab $vivo?: true$
      \State \tab $infoActual: itInfoActual$
      \State $\rangle$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} Copiar y generar iteradores, tuplas y conjuntos es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iCrearEventosConLocalizacion}(\In{localizacion}{tupla(pos, dir))} $\to res:$ lista(evento)} \Comment Función privada
    \begin{algorithmic}[1]
      \State // Pre: true
      \State // Post: se genera una lista con un solo evento que contiene la info de la localizacion
      \\
      \State // Creo el evento
      \State $evento \gets \langle$                 \Comment $\Theta(1)$
      \State \tab $pos: localizacion.pos,$
      \State \tab $dir: localizacion.dir,$
      \State \tab $disparo?: false$
      \State $\rangle$
      \\
      \State // Creo una lista con él
      \State $evts \gets Vacia()$                   \Comment $\Theta(1)$
      \State $AgregarAtras(evts, evento)$           \Comment $\Theta(copy(evento))$
      \\
      \State // La devuelvo
      \State $res \gets evts$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} Copiar y generar tuplas, listas y eventos es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iNuevoFanEspecial}(\Inout{j}{estr}, \In{eventosFan}{vector(evento)})} \Comment Función privada
    \begin{algorithmic}[1]
      \State // Pre: eventosFan no es vacío
      \State // Post: Se agrega un nuevo fantasma (el especial) a todas las estructuras de forma correcta
      \\
      \State // Creo la infoActual y la agrego a su conjunto
      \State $infoActualFan \gets \tuple{posicion: eventosFan[0].pos,\ direccion: eventosFan[0].dir}$ \Comment $\Theta(1)$
      \State $itInfoActualFan \gets AgregarRapido(infoActualFan, j.infoActualFantasmasVivos)$ \Comment $\Theta(copy(infoActual))$
      \\
      \State // Hago que el fantasma especial sea este
      \State $j.infoFantasmaEspecial \gets itInfoActualFan$ \Comment $\Theta(1)$
      \\
      \State // Le doy forma al vector de eventos
      \State $nuevosEventosFan \gets Inversa(eventosFan)$   \Comment $\Theta(Longitud(eventosFan)^2)$
      \\
      \State // Creo la infoFan con la actual
      \State $infoFan \gets \tuple{eventos: nuevosEventosFan,\ vivo?: true,\ infoActual: itInfoActualFan}$ \Comment $\Theta(1)$
      \State // La agrego al conjunto de información de fantasmas y me guardo su iterador
      \State $itInfoFan \gets AgregarRapido(infoFan,\ j.infoFantasmas)$ \Comment $\Theta(copy(infoFan))$
      \\
      \State // Agrego al conjunto de fantasmas vivos el interador a la info del Fan
      \State $AgregarRapido(itInfoFan,\ j.infoFantasmasVivos)$ \Comment $\Theta(copy(itInfoFan))$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(long(eventosFan)^2)$
      \Statex \underline{Justificación:} Copiar y generar iteradores, tuplas y conjuntos es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInfoActualPjVivos}(\In{j}{estr}) $\to res:$ conj(infoActualPJ)}
    \begin{algorithmic}[1]
      \State $res \gets j.infoActualJugadoresVivos$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInfoActualFanVivos}(\In{j}{estr}) $\to res:$ conj(infoActualFan)}
    \begin{algorithmic}[1]
      \State $res \gets j.infoActualFantasmasVivos$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInfoActualFanEspecial}(\In{j}{estr}) $\to res:$ infoActualFan}
    \begin{algorithmic}[1]
      \State $res \gets Siguiente(j.infoFantasmaEspecial)$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInfoActualFanVivosQueDisp}(\In{j}{estr}) $\to res:$ conj(infoActualFan)}
    \begin{algorithmic}[1]
      \State $fantasmasVivosQueDisp \gets Vacio()$
      \\
      \State // Recorro los fantasmas vivos y agrego a res los que estan vivos y disparando
      \For{itInfoFan : \ j.infoFantasmasVivos}                 \Comment $\Theta(\#fv)$
        \State $infoFan \gets Siguiente(itInfoFan)$
        \\
        \State $\textbf{if} \ iEventoActualFan(infoFan, j.paso).disparo?$ 
        \State $\textbf{then} \ AgregarRapido(fantasmasVivosQueDisp,\ Siguiente(infoFan.infoActual))$ \Comment $\Theta(copy(infoActual))$
        \State $\textbf{end if}$
      \EndFor
      \\
      \State $res \gets fantasmasVivosQueDisp$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#fv)$
      \Statex \underline{Justificacion:} Copiar una infoActual es $\Theta(1)$, ya que copiar tuplas y bools es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iVivo?}(\In{j}{estr}, \In{pj}{string}) $\to res:$ bool}
    \begin{algorithmic}[1]
      \State $res \gets Significado(j.infoJugadores, pj).vivo?$ \Comment $\BigO(|pj|)$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(|pj|)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iPasarTiempo}(\Inout{j}{estr})}
    \begin{algorithmic}[1]
      \State // Incremento el paso
      \State $j.paso \gets j.paso + 1$            \Comment $\Theta(1)$
      \\
      \State // Reinicio los disparos de fantasmas
      \State $iReiniciarDisparosFan(j)$                             \Comment $\BigO(\#fv * m)$
      \\
      \State // Actualizo las acciones de los fantasmas,
      \State // actualizando el mapa de disparos si disparan.
      \State $iActualizarFantasmas(j)$   \Comment $\BigO(\#fv * m)$
      \\
      \State // Veo que jugadores mueren
      \State $iChequearMuerteJugadores(j)$        \Comment $\Theta(\#jv)$
      \\
      \State // Agrego los 'pasar' faltantes
      \State $iAgregarPasarFaltantes(j)$          \Comment $\Theta(\#jv)$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(2(\#fv * m) + \#jv) \in \BigO(\#fv * m + \#jv)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAgregarPasarFaltantes}(\Inout{j}{estr})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Recorro a todos los jugadores vivos, y le agrego un pasar a los jugadores que no se movieron
      \For{ptrInfoPJ : j.infoJugadoresVivos}  \Comment $\Theta(\#jv)$
        \State // Si su lista de acciones no es de la misma longitud que el paso actual + 1,
        \State // entonces es necesario agregarle una acción pasar
        \State $\textbf{if}\ Longitud(infoPJ.eventos) \neq j.paso + 1\ \textbf{then}$
        \State \tab // Genero el evento pasar
        \State \tab $eventoPasar \gets \langle$ \Comment $\Theta(1)$
        \State \ttab  $pos: Ultimo(infoPJ.eventos).pos,$
        \State \ttab  $dir: Ultimo(infoPJ.eventos).dir,$   
        \State \ttab  $disparo?: false$
        \State \tab $\rangle$
        \State \tab // Lo agrego al final
        \State \tab $AgregarAtras(infoPJ.eventos, eventoPasar)$ \Comment $\Theta(copy(eventoPasar))$
        \State $\textbf{end if}$
      \EndFor
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#jv)$
      \Statex \underline{Justificacion:} Copiar un evento es $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}[H]{\textbf{iReiniciarDisparosFan}(\Inout{j}{estr})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Vacío la lista de disparos del ultimo paso
      \State // Al asignarle vacío, se libera la memoria que ocupaba anteriormente.
      \State $j.disparosFanUltimoPaso \gets Vacio()$            \Comment $\Theta(Tam(j.disparosFanUltimoPaso))$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#fv * m)$
      \Statex \underline{Justificación:} Vaciar un arreglo de longitud n es $\Theta(n)$. 
      Este arreglo en particular siempre tendrá longitud $\Theta(\#fv * m)$, ya que se llena con los disparos de los fantasmas que estén vivos en ese paso.
      Depende de que tan fino uno hile con el manejo de memoria, podría llegar a tomarse como $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iActualizarFantasmas}(\Inout{j}{estr})} \Comment Función privada
    \begin{algorithmic}[1]
      \State // Recorro los fantasmas vivos
      \State $\textbf{for} \ (itInfoFan :\ j.infoFantasmasVivos) \ \ \textbf{do}$ \Comment $\Theta(\#fv)$
      \State \tab // Obtengo la información del fantasma
      \State \tab $infoFan \gets Siguiente(itInfoFan)$      \Comment $\Theta(1)$
      \\
      \State \tab // Actualizo su información actual, obteniendo el evento actual
      \State \tab $eventoActual \gets iActualizarFan(infoFan,\ j.paso)$   \Comment $\Theta(1)$
      \\
      \State \tab // Si dispara, agrego su disparo a los del paso
      \State \tab $\textbf{if} \ (eventoActual.dispara?) $       
      \State \tab  $\textbf{then}\ iAgregarDisparo(j,\ eventoActual.pos,\ eventoActual.dir,\ true)$ \Comment $\BigO(m)$
      \State \tab $\textbf{end if}$
      \State $\textbf{end for}$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(\#fv * m)$
      \Statex \underline{Justificación:} Tomar referencia del elemento al que apunta un iterador y copiar un evento es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}[H]{\textbf{iActualizarFan}(\Inout{info}{infoFan}, \In{paso}{nat}) $\to res:$ evento} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Obtengo el evento actual
      \State $eventoActual \gets iEventoActualFan(infoFan, paso)$       \Comment $\Theta(1)$
      \\
      \State // Obtengo el iterador a la info actual
      \State $itInfoActual \gets info.infoActual$                       \Comment $\Theta(1)$
      \\
      \State // La actualizo con el $eventoActual$
      \State $Siguiente(itInfoActual).posicion \gets eventoActual.pos$  \Comment $\Theta(1)$
      \State $Siguiente(itInfoActual).direccion \gets eventoActual.dir$ \Comment $\Theta(1)$
      \\
      \State // Devuelvo el evento actual
      \State $res \gets eventoActual$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} Actualizar el iterador y generar el eventoActual es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iChequearMuerteJugadores}(\Inout{j}{estr})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Recorro los jugadores vivos con un iterador
      \State $itPJVivos \gets CrearIt(j.infoJugadoresVivos)$            \Comment $\Theta(1)$
      \While{HaySiguiente(itPJVivos)}                                   \Comment $\Theta(\#jv)$
      \State // Obtengo su evento actual
      \State $ptrInfoPJ \gets Siguiente(itPJVivos)$                     \Comment $\Theta(1)$
      \State $eventoActual \gets iEventoActualPJ(*ptrInfoPJ)$           \Comment $\Theta(1)$
      \\
      \State $\textbf{if}\ iPJAfectadoPorDisparo?(j, eventoActual.pos)$ \Comment $\Theta(1)$
      \State$\textbf{then}\ iMuerePJ(j, itPJVivos)$                    \Comment $\Theta(1)$
      \State $\textbf{end if}$
      \\
      \State // Avanzo el iterador
      \State $Avanzar(itPJVivos)$                                       \Comment $\Theta(1)$
      \EndWhile
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#jv)$
      \Statex \underline{Justificación:} Crear punteros, iteradores y tuplas es $\Theta(1)$.
      \State 
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iPJAfectadoPorDisparo?}(\In{j}{estr}, \In{pos}{pos}) $\to res:$ bool} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // El PJ estará afectado si en la posición en la que está hay un disparo de un fantasma
      \State // Indexo por su posición en el mapa de disparos para obtener el paso en el que hubo un disparo del fantasma
      \State $pasoDispFan \gets j.mapaDisparos[pos.x][pos.y].pasoDispFan$ \Comment $\Theta(1)$
      \\
      \State // Estará afectado si el paso del disparo del fantasma es igual al actual
      \State $afectado? \gets (pasoDispFan == j.paso)$                    \Comment $\Theta(1)$
      \State $res \gets afectado?$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
   \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iMuerePJ}(\Inout{j}{estr}, \Inout{itPJVivos}{itConj(puntero(infoPJ))})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Obtengo su información
      \State $infoPJ \gets *Siguiente(itPJVivos)$               \Comment $\Theta(1)$
      \\
      \State // Lo seteo como muerto
      \State $infoPJ.vivo? \gets false$                         \Comment $\Theta(1)$
      \\
      \State // Lo borro del conjunto infoActualJugadoresVivos
      \State $EliminarSiguiente(infoPJ.infoActual)$             \Comment $\Theta(1)$
      \\
      \State // Lo borro del conjunto infoJugadoresVivos
      \State $EliminarSiguiente(itPJVivos)$                     \Comment $\Theta(1)$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} Las operaciones del iterador son $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAgregarDisparo}(\Inout{j}{estr}, \In{pos}{pos}, \In{dir}{dir}, \In{esFan}{bool})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Copio pos para no modificar el original
      \State $posCopy \gets copy(pos)$  \Comment $\Theta(1)$
      \\
      \State // Parado desde $posCopy$ en $mapaDisparos$, recorro hacia $dir$ 
      \State // hasta que me choco con un obstaculo o la pared.
      \While{Valida?(j.mapa, posCopy) \yluego\ Libre(j.mapa, posCopy)} \Comment $\BigO(Tam(j.mapa))$
        \State // Me guardo una referencia al pasoDisp correcto
        \State $\textbf{if}\ esFan$
        \State $\textbf{then}\ pasoDisp \gets mapaDisparos[pos.x][pos.y].pasoDispFan$ \Comment $\Theta(1)$
        \State $\textbf{else}\ pasoDisp \gets mapaDisparos[pos.x][pos.y].pasoDispPJ$  \Comment $\Theta(1)$
        \State $\textbf{end if}$
        \\ 
        \State // Si no pasé ya por está posición con otro
        \State // (i.e si en el mapa de disparos no está ya el paso actual)
        \State $\textbf{if}\ pasoDisp \neq j.paso\ \textbf{then}$ 
        \State \tab // Le pongo el paso actual al paso en el que hubo un disparo
        \State \tab $pasoDisp \gets j.paso$ \Comment $\Theta(1)$
        \\
        \State \tab // Si es un fantasma, agrego la posición al conjunto de disparos de fantasmas
        \State \tab $\textbf{if}\ esFan$
        \State \tab $\textbf{then}\ AgregarRapido(j.disparosFanUltimoPaso,\ posCopy)$ \Comment $\Theta(copy(posCopy))$
        \State \tab $\textbf{end if}$
        \State $\textbf{end if}$
        \\
        \State // Avanzo la posición en esa dirección
        \State $pos \gets Avanzar(posCopy,\ dir)$          \Comment $\Theta(1)$
      \EndWhile 
      \medskip
      \Statex \underline{Complejidad:} $\BigO(m)$
      \Statex \underline{Justificación:} Copiar naturales, indexar y tomar referencia son $\Theta(1)$. Luego, como hacemos operaciones que son $\Theta(1)$ y lo hacemos a lo sumo Tam(j.mapa) veces, tenemos $\BigO(Tam(j.mapa))$.

    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iEventoActualFan}(\In{info}{infoFan}, \In{paso}{nat}) $\to res:$ evento} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State $idx \gets mod(j.paso, Longitud(info.eventos))$ \Comment $\Theta(1)$
      \State $res \gets info.eventos[idx]$          \Comment $\Theta(1)$
            \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} La operacions matemáticas y la indexación en un vector es $\Theta(1)$.
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iEventoActualPJ}(\In{info}{infoPJ}) $\to res:$ evento} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State $res \gets Ultimo(info.eventos)$     \Comment $\Theta(1)$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} La operación Último sobre una lista es $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}[H]{\textbf{iEjecutarAccion}(\Inout{j}{estr}, \In{a}{accion}, \In{pj}{jugador}) $\to res$ :estr}
    \begin{algorithmic}[1]
      \State // Incremento el paso
      \State $j.paso \gets j.paso + 1$                            \Comment $\Theta(1)$
      \\
      \State // Actualizo la información del jugador con la nueva acción,
      \State // y me guardo una referencia a su info modificada
      \State $infoPJ \gets iActualizarPJ(pj,\ a)$                       \Comment $\BigO(|j|)$
      \State $evtPJ \gets iEventoActualPJ(infoPJ)$                      \Comment $\Theta(1)$
      \\
      \State // Reinicio los disparos de fantasmas
      \State $iReiniciarDisparosFan(j)$                             \Comment $\BigO(\#fv * m)$
      \\
      \State // Modifico el mapa de disparos (solo si dispara)
      \State $iActualizarMapaDisparosConPJ(j,\ evtPJ)$             \Comment $\BigO(m)$
      \\
      \State // Veo que fantasmas mueren, guardandome si murió el fantasma especial
      \State $murioFanEspecial \gets iChequearMuerteFantasmas(j)$  \Comment $\Theta(\#fv)$
      \\
      \State // Si murió el fantasma especial, cambio de ronda
      \State $\textbf{if}\ murioFanEspecial\ \textbf{then}$
      \State \tab $iNuevaRonda(j,\ infoPJ)$  \Comment $\Theta(??)$
      \State $\textbf{else}$
      \State \tab // Sigo en la misma ronda
      \State \tab // Actualizo las acciones de los fantasmas,
      \State \tab // actualizando el mapa de disparos si disparan.
      \State \tab $iActualizarFantasmas(j)$   \Comment $\BigO(\#fv * m)$
      \\
      \State \tab // Veo que jugadores mueren
      \State \tab $iChequearMuerteJugadores(j)$                        \Comment $\Theta(\#jv)$
      \\
      \State \tab // Agrego los 'pasar' faltantes
      \State \tab $iAgregarPasarFaltantes(j)$          \Comment $\Theta(\#jv)$
      \State $\textbf{end if}$
      \medskip
      \Statex \underline{Complejidad:} Sin cambiar de ronda $\BigO(|j| + m + \#fv + \#fv * m + \#jv) \in \BigO(|j| + \#fv * m + \#jv)$, cambiando $\BigO(?)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iPosOcupadasPorDisparosFan}(\In{j}{estr}) $\to res:$ conj(posicion)}
    \begin{algorithmic}[1]
      \State $res \gets j.disparosFanUltimoPaso$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$ EXPLICAR QUE ESTO LO RELLENAMOS ANTES Y QUE COMO ES PARTE DE LA ESTRUCTURA ES TETA DE 1
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iHabitacion}(\In{j}{estr}) $\to res:$ mapa}
    \begin{algorithmic}[1]
      \State $res \gets j.mapa$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iFantasmas}(\In{j}{estr}) $\to res:$ conj(vector(evento))}
    \begin{algorithmic}[1]
      \State res $\gets$ vacio()
      \State $\textbf{for} \ (infoFan : \ j.infoFantasmas) \ \ \textbf{do}$                         \Comment $\Theta(\#fantasmas)$
      \State \tab  AgregarRapido(res, infoFan.eventos)                             \Comment $\Theta(infoFan.eventos)$ 
      \State $\textbf{end for}$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(?)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iFantasmaEspecial}(\In{j}{estr}) $\to res:$ vector(evento)}
    \begin{algorithmic}[1]
      \State $\textbf{for} \ (infoFan : \ j.infoFantasmas) \ \ \textbf{do}$                         \Comment $\Theta(\#fantasmas)$
      \State \tab $\textbf{if} \ (Siguiente(infoFan.infoActual) == Siguiente(j.infoFantasmaEspecial))$ 
      \State \ttab $\textbf{then} \ res \gets infoFan.eventos$
      \State \tab $\textbf{end if}$
      \State $\textbf{end for}$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#fantasmas)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iJugadores}(\In{j}{estr}) $\to res:$ conj(string)}
    \begin{algorithmic}[1]
      \State $res \gets Claves(j.infoJugadores)$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAcciones}(\In{pj}{string}, \In{j}{estr}) $\to res:$ lista(evento)}
    \begin{algorithmic}[1]
      \State $res \gets Significado(j.infoJugadores, pj).eventos$          \Comment $\Theta(|pj|)$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(|pj|)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iActualizarMapaDisparosConPJ}(\Inout{j}{estr}, \In{evtPJ}{evento})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Si dispara, agrego las posiciones afectadas por su disparo al mapa de disparos.
      \State $\textbf{if}\ evtPJ.dispara?$
      \State $\textbf{then}\ iAgregarDisparo(j, evtPJ.pos, evtPJ.dir, false)$ \Comment $\BigO(m)$
      \State $\textbf{end if}$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(m)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iChequearMuerteFantasmas}(\Inout{j}{estr}) $\to res:$ bool} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Me guardo si el fantasma especial muere
      \State $muereFanEspecial \gets false$
      \\
      \State // Recorro los fantasmas vivos con un iterador
      \State $itFanVivos \gets CrearIt(j.infoFantasmasVivos)$ \Comment $\Theta(\#fv)$
      \\
      \While{HaySiguiente(itFanVivos)}
        \State // Obtengo su info
        \State $infoFan \gets Siguiente(Siguiente(itFanVivos))$ \Comment $\Theta(1)$
        \\
        \State // Obtengo su evento actual
        \State $eventoActual \gets iEventoActualFan(infoFan,\ j.paso)$  \Comment $\Theta(1)$
        \\
        \State $\textbf{if}\ iFanAfectadoPorDisparo(j,\ eventoActual.pos)?$      \Comment $\Theta(1)$
        \State $\textbf{then}\ muereFanEspecial \gets iMuereFan(j,\ itFanVivos)$ \Comment $\Theta(1)$
        \State $\textbf{end if}$
        \\
        \State // Avanzo el iterador
        \State $Avanzar(itFanVivos)$  \Comment $\Theta(1)$
      \EndWhile
      \\
      \State // Retorno si murio el fan especial
      \State $res \gets muereFanEspecial$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#fv)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iFanAfectadoPorDisparo}(\In{j}{estr}, \In{pos}{pos}) $\to res:$ bool} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // El Fan estará afectado si en la posición en la que está hay un disparo de un PJ en el paso actual
      \State // Indexo por su posición en el mapa de disparos
      \State $pasoDispPJ \gets j.mapaDisparos[pos.x][pos.y].pasoDispPJ$ \Comment $\Theta(1)$
      \\
      \State // Estará afectado si el paso del disparo del PJ es igual al actual
      \State $afectado? \gets (pasoDispPJ == j.paso)$                    \Comment $\Theta(1)$
      \State $res \gets afectado?$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iMuereFan}(\Inout{j}{estr}, \Inout{itFanVivos}{itConj(itConj(infoFan))}) $\to res:$ bool} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Obtengo la info
      \State $infoFan \gets Siguiente(Siguiente(itFanVivos))$         \Comment $\Theta(1)$
      \\
      \State // Lo seteo como muerto
      \State $infoFan.vivo? \gets false$                              \Comment $\Theta(1)$
      \\
      \State // Obtengo la info actual
      \State $itInfoActual \gets infoFan.infoActual$  \Comment $\Theta(1)$
      \\
      \State // Veo si es el fantasma especial
      \State $eraFanEspecial \gets (itInfoActual == j.infoFantasmaEspecial)$  \Comment $\Theta(1)$
      \\
      \State // Lo borro de infoActualFantasmasVivos
      \State $EliminarSiguiente(itInfoActual)$  \Comment $\Theta(1)$
      \\
      \State // Lo borro de infoFantasmasVivos
      \State $EliminarSiguiente(itFanVivos)$  \Comment $\Theta(1)$
      \\
      \State // Retorno si era el fantasma especial
      \State $res \gets eraFanEspecial$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iNuevaRonda}(\Inout{j}{estr}, \In{pjMatoFanEspecial}{infoPJ})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Incremento la ronda
      \State $j.ronda \gets j.ronda + 1$  \Comment $\Theta(1)$
      \\
      \State // Reinicio el paso
      \State $j.paso \gets 0$             \Comment $\Theta(1)$
      \\
      \State // Reinicio el mapa de disparos y los disparos de los fantasmas
      \State $iReiniciarMapaDisparos(j)$  \Comment $\Theta(m^2)$
      \State $iReiniciarDisparosFan(j)$   \Comment $\BigO(\#fv * m)$
      \\
      \State // Reinicio los fantasmas
      \State $iReiniciarFantasmas(j, pjMatoFanEspecial)$  \Comment $\Theta(\#fv + long(pjMatoFanEspecial.eventos))$
      \\
      \State // Reinicio los jugadores
      \State $iReiniciarJugadores(j)$ \Comment $\BigO(locJugadores + \sum{long(eventos\ pjs)})$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(m^2 + \#fv + \sum{long(eventos\ pjs)}))$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iReiniciarMapaDisparos}(\Inout{j}{estr})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Recorro todas las posiciones y las pongo en 0
      \State $\textbf{for}\ i \gets 0 ... Tam(j.mapaDisparos)$        \Comment $\Theta(m^2)$
      \State \tab $\textbf{for}\ j \gets 0 ... Tam(j.mapaDisparos)$   \Comment $\Theta(m)$
      \State \ttab $j.mapaDisparos[i][j].pasoDispFan \gets 0$         \Comment $\Theta(1)$
      \State \ttab $j.mapaDisparos[i][j].pasoDispPJ \gets 0$          \Comment $\Theta(1)$
      \State \tab $\textbf{end for}$
      \State $\textbf{end for}$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(m^2)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iReiniciarFantasmas}(\Inout{j}{estr}, \In{pjMatoFanEspecial}{infoPJ})} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Vacío la información de los fantasmas vivos, liberando la memoria que ocupaba.
      \State $infoFantasmasVivos \gets Vacio()$         \Comment $\Theta(\#fv)$
      \State $infoActualFantasmasVivos \gets Vacio()$   \Comment $\Theta(\#fv)$
      \\
      \State // Recorro $infoFantasmas$ con un iterador
      \State $itInfoFan \gets CrearIt(j.infoFantasmas)$ \Comment $\Theta(1)$
      \While{HaySiguiente(itInfoFan)}
        \State // Obtengo su info
        \State $info \gets Siguiente(itInfoFan)$ \Comment $\Theta(1)$
        \\
        \State // Lo seteo como vivo
        \State $info.vivo? \gets true$  \Comment $\Theta(1)$
        \\
        \State // Creo su $infoActual$ y la agrego a $infoActualFantasmasVivos$, guardandome su iterador
        \State $infoActualFan \gets \tuple{posicion: info.eventos[0].pos,\ direccion: info.eventos[0].dir}$ \Comment $\Theta(1)$
        \State $itInfoActualFan \gets AgregarRapido(infoActualFan, j.infoActualFantasmasVivos)$             \Comment $\Theta(1)$
        \\
        \State // Le seteo el iterador a la info actual
        \State $info.infoActual \gets itInfoActualFan$                \Comment $\Theta(1)$
        \\
        \State // Agrego un iterador a su info a $infoFantasmasVivos$ 
        \State $AgregarRapido(itInfoFan, j.infoFantasmasVivos)$       \Comment $\Theta(copy(itInfoFan)))$
      \EndWhile
      \\
      \State // Agrego un nuevo fantasma especial con los eventos del personaje
      \State $iNuevoFanEspecial(j, pjMatoFanEspecial.eventos)$ \Comment $\Theta(long(nuevosEventosFan))$
      \medskip
      \Statex \underline{Complejidad:} $\Theta(\#fv + long(pjMatoFanEspecial.eventos))$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iReiniciarJugadores}(\Inout{j}{estr}} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Obtengo sus localizaciones
      \State $localPJs \gets localizarJugadores(j.mapa, Claves(j.infoJugadores))$ \Comment $\Theta(locJugadores)$
      \\
      \State // Por cada clave y valor de las localizaciones,
      \State $\textbf{for}\ pj, localizacion : localPJs\ \textbf{do}$
      \State \tab // Obtengo $infoPJ$ del trie por referencia modificable
      \State \tab $infoPJ \gets Significado(j.infoJugadores, pj)$
      \\
      \State \tab // Vacío los eventos, así liberando la memoria que ocupaban
      \State \tab $infoPJ.eventos \gets Vacia()$    \Comment $\Theta(\#infoPJ.eventos)$
      \\
      \State \tab // Creo una lista de eventos con la localización y se la seteo
      \State \tab $infoPJ.eventos \gets iCrearEventosConLocalizacion(localizacion)$ \Comment $\Theta(1)$
      \\
      \State \tab // Lo seteo como vivo
      \State \tab $infoPJ.vivo? \gets true$ \Comment $\Theta(1)$
      \\
      \State \tab // Creo una info actual
      \State \tab $infoActualPJ \gets \tuple{identidad: pj, posicion: localizacion.pos, direccion: localizacion.dir}$ \Comment $\Theta(1)$
      \\
      \State \tab // La agrego a $infoActualJugadoresVivos$ y me guardo itInfoActual
      \State \tab $itInfoActual \gets AgregarRapido(j.infoActualJugadoresVivos, infoActualPJ)$  \Comment $\Theta(1)$
      \\
      \State \tab // Le seteo infoActual a infoPJ con el iterador
      \State \tab $infoPJ.infoActual \gets itInfoActual$  \Comment $\Theta(1)$
      \\
      \State \tab // Agrego un puntero a la infoPJ a $infoJugadoresVivos$
      \State \tab $AgregarRapido(j.infoJugadoresVivos, \&infoPJ)$ \Comment $\Theta(1)$      \medskip
      \State $\textbf{end for}$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(locJugadores + \sum{long(eventos\ pjs)})$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iActualizarPJ}(\In{pj}{jugador}, \In{a}{accion}) $\to res:$ infoPJ} \Comment Funcion privada
    \begin{algorithmic}[1]
      \State // Busco la información del PJ
      \State $infoPJ \gets Significado(j.infoJugadores,\ pj)$          \Comment $\BigO(|j|)$
      \\
      \State // Genero un evento con la acción y el evento anterior (el actual)
      \State $evtPJ \gets Aplicar(a,\ j,\ iEventoActualPJ(infoPJ))$ \Comment $\Theta(1)$
      \\
      \State // Agrego el evento al jugador
      \State $AgregarAtras(infoPJ.eventos,\ evtPJ)$                \Comment $\Theta(1)$
      \\
      \State // Obtengo su información actual
      \State $itInfoActual \gets infoPJ.infoActual$             \Comment $\Theta(1)$
      \\
      \State // La actualizo
      \State $Siguiente(itInfoActual).posicion \gets evt.pos$   \Comment $\Theta(1)$
      \State $Siguiente(itInfoActual).direccion \gets evt.dir$  \Comment $\Theta(1)$
      \\
      \State // Devuelvo la info del pj
      \State $res \gets infoPJ$
      \medskip
      \Statex \underline{Complejidad:} $\BigO(|j|)$
    \end{algorithmic}
  \end{algorithm}

  \end{Algoritmos}

\newpage

\section{Módulo Mapa}

El módulo Mapa provee una habitación en la que se puede ocupar y consultar por una posición en $\Theta(1)$. 

\begin{Interfaz}
  
  \textbf{generos}: \TipoVariable{mapa}.

  \textbf{se explica con}: \tadNombre{Habitación}.

  \Titulo{Operaciones básicas del mapa}
  \InterfazFuncion{nuevoMapa}{\In{n}{nat}}{mapa}%
  {$res \igobs nuevaHab(n)$}%
  [$\Theta(n^2)$]
  [genera un mapa de tamaño n x n.]

  \InterfazFuncion{ocupar}{\Inout{m}{mapa}, \In{p}{pos}}{}%
  [$m \igobs m_0$ $\land$ $p \in casilleros(m)$ $\yluego$ $libre(m, p)$ $\land$ $alcanzan(libres(m)-p,\ libres(m)-p,\ m)$]
  %lo de m = m0 es igualdad observacional, no?
  {$m$ $\igobs$ $ocupar(c,m_0)$}%
  [$\Theta(1)$]
  [ocupa una posición del mapa siempre y cuando éste no deje de ser conexo.]

  \InterfazFuncion{tam}{\In{m}{mapa}}{nat}%
  {$res$ $\igobs$ $tam(m)$}%
  [$\Theta(1)$]
  [devuelve el tamaño del mapa.]
    
  \InterfazFuncion{libre}{\In{m}{mapa}, \In{p}{pos}}{bool}%
  [$p \in casilleros(m)$]%
  {$res$ $\igobs$ $libre(p, m)$}
  [$\Theta(1)$]
  [devuelve si una posición está ocupada.]

  \InterfazFuncion{Valida?}{\In{m}{mapa}, \In{p}{pos}}{bool}%
  {$res$ $\igobs$ $0 \leq \Pi_1(pos) < tam(m) \land\ 0 \leq \Pi_1(pos) < tam(m)$}
  [$\Theta(1)$]
  [devuelve si una posición es válida en el mapa.]

  \InterfazFuncion{Copiar}{\In{m}{mapa}}{mapa}%
  {$res$ $\igobs$ $m$}
  [$\Theta(????)$]
  [devuelve si una posición está ocupada.]
  [se devuelve una copia del elemento ingresado por referencia.]

\end{Interfaz}
\mbox{}

\begin{Representacion}
  
  \Titulo{Representación del mapa}
  \mbox{}

  El objetivo de este módulo es implementar una matriz de tamaño n con vectores de booleanos que indican si una posición está ocupada. La estructura de representación, su invariante de representación y su función de abstracción son las siguientes.

  \begin{Estructura}{mapa}[map]
    \begin{Tupla}[map]
      \tupItem{tamano}{nat}%
      \tupItem{casilleros}{vec(vec(bool))}%
    \end{Tupla}
  \end{Estructura}

  \Rep[mapa][map]{
    La longitud de map.casilleros es igual a tamano $\land$\\
    La longitud del vector m.casilleros es igual a la de todo otro vector dentro de el) $\land$\\
    Toda posición libre debe ser alcanzable por todo el resto de las posiciones libres a través de un camino de posiciones libres (conexo).
  }\mbox{}

  \Abs[mapa]{hab}[map]{h}{$m.tamano$ $\igobs$ $tam(h)$ $\yluego$\\
    ($\forall t$: tupla(nat,nat))($0 \leq$ $\Pi_1(t)$, $\Pi_2(t) < map.tamano - 1$ $\impluego$\\
    libre(h, t) $\igobs$ $map.casilleros[\Pi_1(t)][\Pi_2(t)]$)}

\end{Representacion}

\bigskip

\begin{Algoritmos}

  %%Si quieren agregar algún abstract antes de los algoritmos, ponganlo aquí%%
\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iTam}(\In{m}{map}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
       \State $res \gets m.tamano$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iOcupar}(\Inout{m}{map}, \In{p}{pos})}
  \begin{algorithmic}[1]
			 \State $m[\Pi_1(p)][\Pi_2(p)] \gets true$ 				\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificación:} El acceso a una posición de un vector y su modificación es $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iLibre}(\In{m}{map}, \In{p}{pos}) $\to$ $res$ : bool}
	\begin{algorithmic}[1]
			 \State $res \gets \neg \ m[\Pi_1(p)][\Pi_2(p)]$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:} El acceso a una posición de un vector es $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	

\begin{algorithm}[H]{\textbf{iNuevoMapa}(\In{n}{nat}) $\to$ $res$ : $map$}
  \begin{algorithmic}[1]
    \State // Inicializo el tamaño, el vector y el mapa.
      \State $res \gets \tuple{tamano: n,\ casilleros: Vacia()}$ \Comment $\Theta(1)$
      \\
      \State // Genero un vector de booleanos en falso con n posiciones.
      \State $i \gets 0$                          \Comment $\Theta(1)$
      \While{$i < n$}                             \Comment $\BigO(n^2)$
        \State $v.AgregarAtras(false)$            \Comment $\BigO(n)$
        \State $i \gets i + 1$
      \EndWhile
      \\
      \State // Genero la matriz de n x n posiciones haciendo n copias del vector de booleanos antes creado.
      \State $i \gets 0$
      \While{$i < n$}                             \Comment $\BigO(n^2)$
        \State $res.AgregarAtras(v.Copiar())$     \Comment $\BigO(n)$
        \State $i \gets i + 1$                    \Comment $\Theta(1)$
      \EndWhile
      \medskip
      \Statex \underline{Complejidad:} $\BigO(n^2)$
      \Statex \underline{Justificación:} Copiar un vector de n booleanos es $\BigO(n * copy(bool))$ y copiar un bool es $\Theta(1)$. Luego, agregar n veces la copia del vector es $\BigO(n^2)$, puesto que AgregarAtrás es $\BigO(n)$ y copiarlo es $\BigO(n)$ por lo antes visto. Luego la complejidad de la operación de la línea 10 es $\BigO(n)$ y, por lo tanto, todo el while es $\BigO(n^2)$.
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iValida?}(\In{m}{map} \In{p}{pos}) $\to$ $res$ : nat}
  \begin{algorithmic}[1]
   \State $res \gets 0 \leq pos.x, \ pos.y < m.tamano$ \Comment $\Theta(1)$
  \medskip
  \Statex \underline{Complejidad:} $\Theta(1)$
  \end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iCopiar}(\In{m}{map}) $\to$ $res$ : map}
  \begin{algorithmic}[1]
   \State $res \gets \tuple{tamano: m.tamano,\ casilleros: Copiar(m.casilleros)}$ \Comment $\Theta(m.tamano^2)$
  \medskip
  \Statex \underline{Complejidad:} $\Theta(1)$
  \Statex \underline{Justificación:} Copiar un vector es $\displaystyle\Theta\left(\sum_{i=1}^{\ell}copy({v[i]})\right)$, donde $\ell$ $=$ long($v$). Luego, copiar un vector de vectores de booleanos de tamano n es $\Theta(m.tamano^2)$.
  \end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\newpage

\section{Módulo Dirección}

El módulo Dirección provee una dirección y una función que permite invertir las mismas.

\begin{Interfaz}
  \textbf{generos}: \TipoVariable{dir}.

  \textbf{se explica con}: \tadNombre{Dirección}.

  \Titulo{Operaciones básicas de Dirección}

  \InterfazFuncion{arriba}{}{dir}%
  {$res \igobs  \uparrow$}%
  [$\Theta(1)$]
  [genera la dirección arriba.]

  \InterfazFuncion{abajo}{}{dir}%
  {$res \igobs  \downarrow$}%
  [$\Theta(1)$]
  [genera la dirección abajo.]

  \InterfazFuncion{izquierda}{}{dir}%
  {$res \igobs  \leftarrow$}%
  [$\Theta(1)$]
  [genera la dirección izquierda.]

  \InterfazFuncion{derecha}{}{dir}%
  {$res \igobs  \rightarrow$}%
  [$\Theta(1)$]
  [genera la dirección derecha.]

  \InterfazFuncion{invertir}{\Inout{d}{dir}}{}
  {$res \igobs invertir(d)$}
  [$\Theta(1)$]
  [invierte la dirección.]

\end{Interfaz}

\begin{Representacion}
  
  El objetivo de este módulo es implementar una dirección utilizando strings. La estructura de representación, su invariante de representación y su función de abstracción son las siguientes.

  \Titulo{Representación de Dirección}

  \begin{Estructura}
    {dir}[string]
  \end{Estructura}

  \Rep[dir][d]{\\
    d \igobs $"arriba"$    $\lor$\\
    d \igobs $"abajo"$     $\lor$\\
    d \igobs $"izquierda"$ $\lor$\\
    d \igobs $"derecha"$
  }
  
  \mbox{}
  \mbox{}

  \Abs[dir]{dir}[d]{d$_{tad}$}{(d \igobs $"arriba"$  $\land$ d$_{tad}$ \igobs $\uparrow$) $\lor$\\
  (d \igobs $"abajo"$     $\land$ d$_{tad}$ \igobs $\uparrow$)   $\lor$\\
  (d \igobs $"izquierda"$ $\land$ d$_{tad}$ \igobs $\leftarrow$) $\lor$\\
  (d \igobs $"derecha"$   $\land$ d$_{tad}$ \igobs $\rightarrow$)
  }

\end{Representacion}

\bigskip

\begin{Algoritmos}
  \Titulo{Algoritmos del módulo}
  \medskip
  
  \begin{algorithm}[H]{\textbf{iArriba}() $\to$ $res$ : dir}
    	\begin{algorithmic}[1]
       \State $res \gets "arriba"$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAbajo}() $\to$ $res$ : dir}
    \begin{algorithmic}[1]
     \State $res \gets "abajo"$ \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}
  
  \begin{algorithm}[H]{\textbf{iIzquierda}() $\to$ $res$ : dir}
    \begin{algorithmic}[1]
     \State $res \gets "izquierda"$ \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}[H]{\textbf{iDerecha}() $\to$ $res$ : dir}
    \begin{algorithmic}[1]
     \State $res \gets "derecha"$ \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInvertir}(\Inout{d}{dir})}
    \begin{algorithmic}[1]
     \State $switch(d)$         \Comment $\Theta(1)$
     \State $case\ "arriba":$
     \State $\tab d \gets "abajo"$
     \State $case\ "abajo":$
     \State $\tab d \gets "arriba"$ %skere
     \State $case\ "izquierda":$
     \State $\tab d \gets "derecha"$
     \State $case\ "derecha":$
     \State $\tab d \gets "izquierda"$

    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

\end{Algoritmos}

\newpage

\section{Módulo Acción}

El módulo Acción provee una acción y una funciones que permiten operar con acciones y eventos.

\begin{Interfaz}
  \textbf{generos}: \TipoVariable{accion}.

  \textbf{se explica con}: \tadNombre{Acción}.

  \Titulo{Operaciones básicas de Acción}

  \InterfazFuncion{Mover}{\In{d}{dir}}{accion}%
  {$res \igobs mover(d)$}%
  [$\Theta(1)$]
  [genera una acción de mover en la dirección especificada.]
  
  \InterfazFuncion{Pasar}{}{accion}%
  {$res \igobs pasar$}%
  [$\Theta(1)$]
  [genera la acción de pasar.]

  \InterfazFuncion{Disparar}{}{accion}%
  {$res \igobs disparar$}%
  [$\Theta(1)$]
  [genera la acción de disparar.]

  \InterfazFuncion{Aplicar}{\In{a}{acción}, \In{j}{juego}, \In{e}{evento}}{evento}%
  {$res \igobs aplicar(a,\ j,\ e)$}%
  [$\Theta(1)$]
  [genera el evento a partir de la acción a realizar.]


  \InterfazFuncion{Invertir}{\In{e}{evento}}{evento}%
  {$res \igobs invertir(e)$}%
  [$\Theta(1)$]
  [invierte un evento.]

  \InterfazFuncion{Inversa}{\Inout{es}{vector(evento)}}{vector(evento)}%
  {$res \igobs inversaReal(es)$}%
  [$\Theta(long(es)^2)$]
  [genera una secuencia que contiene a la inicial, le suma 5 pasos de espera y le agrega la secuencia original invertida.]

  \InterfazFuncion{Avanzar}{\In{p}{pos}, \In{d}{dir}}{pos}%
  {$d \igobs \ \uparrow \land \ res \igobs \tuple{\Pi_1(pos)+1,\Pi_2(pos)}\ \lor \\
  d \igobs \ \downarrow \land \ res \igobs \tuple{\Pi_1(pos)-1,\Pi_2(pos)}\ \lor \\
  d \igobs \ \leftarrow \land \ res \igobs \tuple{\Pi_1(pos),\Pi_2(pos)-1}\ \lor \\
  d \igobs \ \rightarrow \land \ res \igobs \tuple{\Pi_1(pos)+1,\Pi_2(pos)+1}$}%
  [$\Theta(1)$]
  [devuelve la posición correspondiente a moverse en la dirección indicada.]

\end{Interfaz}

\Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
    \begin{tad}{Acción Extendida($\alpha$)}
      \parskip=0pt
      \tadExtiende{\tadNombre{Acción}}
    
      \tadTitulo{otras operaciones}
      \tadOperacion{inversaReal}{secu(evento)}{secu(evento)}{}
      \tadOperacion{pasar}{evento}{evento}{}
       \tadAxiomas
      \tadAxioma{inversasReal(es)}{$ es\ \& (pasar(ult(es)) \bullet pasar(ult(es)) \bullet pasar(ult(es)) \bullet pasar(ult(es)) \bullet pasar(ult(es)) \ \bullet <> \ \& \ inversa(es)$}
      \tadAxioma{pasar(evt)}{$\tuple{\Pi_1(evt),\ \Pi_2(evt),\ false}$}
    \end{tad}

\begin{Representacion}
  
  \Titulo{Representación de Acción}
  \mbox{}

  El objetivo de este módulo es implementar una acción utilizando una tupla de string y dirección. La estructura de representación, su invariante de representación y su función de abstracción son las siguientes.

  \begin{Estructura}{acción}[a]
    \begin{Tupla}[a]
      \tupItem{acción}{string}
      \tupItemF{dir}{dir}
    \end{Tupla}
  \end{Estructura}

  \Rep[acción][a]{\\
  a.acción \igobs $"disparar"$    $\lor$\\
  a.acción \igobs $"pasar"$     $\lor$\\
  a.acción \igobs $"mover"$
  }
  
  \mbox{}

  \Abs[acción]{acción}[a]{a$_{tad}$}{(a.acción \igobs $"disparar"$  $\land$ $esDisparar(a_{tad}))$ $\lor$\\
  (a.acción \igobs $"pasar"$  $\land$ $esPasar(a_{tad}))$ $\lor$\\
  ((a.acción \igobs $"mover"$  $\land$ $esMover(a_{tad}))$ $\yluego$ a.dir \igobs $direccion(a_{tad}))$
  }

\end{Representacion}

\bigskip

\begin{Algoritmos}

\noindent{Para las acciones que no tienen dirección, les definimos la dirección $Arriba()$.\\}
Esto no importa ya que la dirección es ignorada en general para esas acciones.
\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
    
  \begin{algorithm}[H]{\textbf{iPasar}() $\to$ $res$ : acción}
        \begin{algorithmic}[1]
        \State $res \gets \tuple{accion: "pasar",\ dir:  Arriba()}$      \Comment $\Theta(1)$
        \medskip
        \Statex \underline{Complejidad:} $\Theta(1)$
        \end{algorithmic}
      \end{algorithm}

  \begin{algorithm}[H]{\textbf{iDisparar}() $\to$ $res$ : acción}
        \begin{algorithmic}[1]
        \State $res \gets \tuple{accion: "disparar",\ dir:  Arriba()}$      \Comment $\Theta(1)$
        \medskip
        \Statex \underline{Complejidad:} $\Theta(1)$
        \end{algorithmic}
      \end{algorithm}

  \begin{algorithm}[H]{\textbf{iMover}(\In{d}{dir}) $\to$ $res$ : acción}
        \begin{algorithmic}[1]
        \State $res \gets \tuple{accion: "mover",\ dir:  d}$      \Comment $\Theta(1)$
        \medskip
        \Statex \underline{Complejidad:} $\Theta(1)$
        \end{algorithmic}
      \end{algorithm}


  \begin{algorithm}[H]{\textbf{iInvertir}(\In{e}{evento}) $\to$ $res$ : evento}
    \begin{algorithmic}[1]
    \State $res \gets \tuple{pos: e.pos,\ dir: Invertir(e.dir),\ disparo?: e.disparo?}$      \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic})
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAvanzar}(\In{p}{pos}, \In{d}{dir}) $\to$ $res$ : pos}
    \begin{algorithmic}[1]
      \State $switch(d)$         \Comment $\Theta(1)$
      \State $case\ Arriba():$
      \State $\tab res \gets \tuple{pos.x + 1,\ pos.y}$
      \State $case\ Abajo():$
      \State $\tab res \gets \tuple{pos.x - 1,\ pos.y}$
      \State $case\ Izquieda():$
      \State $\tab res \gets \tuple{pos.x,\ pos.y - 1}$
      \State $case\ Derecha():$
      \State $\tab res \gets \tuple{pos.x,\ pos.y + 1}$
      \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic})
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInversa}(\Inout{es}{vector(evento)})}
    \begin{algorithmic}[1]
      \State // El resultado deseado es el siguiente
      \\
      \State // Copio el vector de entrada    
      \State $esCopy \gets copy(es)$          \Comment $\Theta(long(es))$
      \\
      \State // Me guardo la longitud original
      \State $longOriginal \gets Longitud(es)$
      \\
      \State // Creo un evento que sea pasar y lo agrego 5 veces
      \State $eventoPasar \gets \tuple{pos: Ultimo(esCopy).pos,\ dir: Ultimo(esCopy).dir,\ disparo?: false} $   \Comment $\Theta(1)$
      \State $\textbf{for} \ (i = 0,\ ... \ , 4) \ \ \textbf{do}$                                               \Comment $\BigO(long(es)*5)$
      \State \tab $AgregarAtras(esCopy,\ eventoPasar)$                                                          \Comment $\BigO(long(es))$
      \State $\textbf{end for}$
      \\
      \State // Recorro los eventos de la secuencia original de atrás para adelante,
      \State // invirtiendolos y agregándolos al final
      \State $\textbf{for} \ (i = longOriginal - 1,\ ... \ , 0) \ \ \textbf{do}$                            \Comment $\BigO(long(es)^2)$
      \State \tab $AgregarAtras(esCopy,\ invertir(esCopy[i]))$                                              \Comment $\BigO(long(es))$
      \State $\textbf{end for}$
      \\
      \State // Devuelvo los eventos
      \State $res \gets esCopy$
      \medskip
    \Statex \underline{Complejidad:} $\BigO(long(es)^2)$
    \Statex \underline{Justificación:} Crear una tupla y acceder al vector es $\Theta(1)$. $\BigO(long(es)*5)$ + $\BigO(long(es)^2)$ = $\BigO(long(es)^2)$.

    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAplicar}(\In{a}{acción}, \In{j}{juego}, \In{e}{evento}) $\to$ $res$ : evento}
        \begin{algorithmic}[1]
          \State $\textbf{if} \ (a.accion = disparar) $        \Comment $\Theta(1)$
          \State \tab   $\textbf{then} \ res \gets \tuple{pos: e.pos,\ dir: e.dir,\ disparo?: true}$       \Comment $\Theta(1)$
          \State $\textbf{end if}$
          \\

          \State $\textbf{if} \ (a.accion = pasar) $        \Comment $\Theta(1)$
          \State \tab   $\textbf{then} \ res \gets \tuple{pos: e.pos,\ dir: e.dir,\ disparo?: false}$       \Comment $\Theta(1)$
          \State $\textbf{end if}$
          \\

          \State $\textbf{if} \ (a.accion = mover) \ \textbf{then}$        \Comment $\Theta(1)$
          \State \tab $prox \gets Avanzar(e.pos,\ a.dir)$

          \State \tab $\textbf{if} \ (Valida?(j.mapa,\ prox)\ \yluego$ $Libre(j.mapa,\ prox))$        \Comment $\Theta(1)$
          \State \ttab   $\textbf{then} \ res \gets \tuple{pos: prox,\ dir: a.dir,\ disparo?: false}$       \Comment $\Theta(1)$
          \State \ttab  $\textbf{else} \ res \gets \tuple{pos: e.pos,\ dir: a.dir,\ disparo?: false}$ 
          \State \tab $\textbf{end if}$
          \State $\textbf{end if}$
          
          \medskip
        \Statex \underline{Complejidad:} $\Theta(1)$
        \Statex \underline{Justificación:} Crear una tupla, comparar sus elementos y las operaciones del mapa son $\Theta(1)$. 
        \end{algorithmic}
      \end{algorithm}

\end{Algoritmos}

\newpage


\end{document}