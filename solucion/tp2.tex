% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a p�gina completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={C�tedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={M�dulos b�sicos},
 pdftitle={M�dulos b�sicos de dise�o},
 pdfsubject={M�dulos b�sicos de dise�o}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$1^\mathrm{er}$ cuatrimestre de 2019}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Apunte de M�dulos B�sicos (v.\ 0.3$\alpha$)}
\author{Algoritmos y Estructuras de Datos II, DC, UBA.}
\date{\Cuatrimestre}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{\Cuatrimestre}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}
\newcommand{\ttab}{\tab \tab}
\newcommand{\tttab}{\tab \tab \tab}
\newcommand{\ttttab}{\tab \tab \tab \tab}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripci�n:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representaci�n}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \emph{#2}: \TipoVariable{#3},%
}
\newcommandx{\tupItemF}[3][1={\ }]{%
    %\hspace*{3mm}%
    \emph{#2}: \TipoVariable{#3}%
}

\newcommandx{\Comentario}[1]{
  // #1\\
}

%\newcommandx{\tupItem}[3][1={\ }]{%
%    %\hspace*{3mm}%
%    \ifthenelse{\boolean{EstructuraHayItems}}{%
%        ,#1%
%    }{}%
%    \emph{#2}: \TipoVariable{#3}%
%    \setboolean{EstructuraHayItems}{true}%
%}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}
\newcommand{\BigO}{\ensuremath{\mathcal{O}}}
\newcommand{\tuple}[1]{\langle #1 \rangle}

\begin{document}

%pagina de titulo
\thispagestyle{empty}
\maketitle
\tableofcontents

\newpage

%for jugador, posInicial in jugadores:
%    it = infoJugadores.add(jugador, infoPJ{})
%    jugadores.definir(jugador, it)

\section{Diccionario Trie ($\alpha$)}

  \noindent{El m�dulo Diccionario Trie provee un diccionario b�sico montado sobre un trie.\\
  Solo se definen e implementan las operaciones que ser�n utilizadas.

  \begin{Interfaz}

    \textbf{par�metros formales}\hangindent=2\parindent\\
    \parbox{1.7cm}{\textbf{g�neros}}$\alpha$\\
    \parbox[t]{1.7cm}{\textbf{funci�n}}\parbox[t]{.5\textwidth-\parindent-1.7cm}{%
      \InterfazFuncion{Copiar}{\In{s}{$\alpha$}}{$\alpha$}
      {$res \igobs s$}
      [$\Theta(copy(s))$]
      [funci�n de copia de $\alpha$]
    }

    \textbf{se explica con}: \tadNombre{Diccionario$(string, \alpha)$}.

    \textbf{g�neros}: \TipoVariable{diccTrie$(string, \alpha)$}.

    \Titulo{Operaciones b�sicas de diccionario}

    \InterfazFuncion{Vac�o}{}{diccTrie$(string, \alpha)$}%
    {$res$ $\igobs$ vacio}%
    [$\Theta(1)$]
    [genera un diccionario vac�o.]

    \InterfazFuncion{Definir}{\Inout{d}{diccTrie($string$, $\alpha$)}, \In{k}{$string$}, \In{s}{$\alpha$}}{}
    [$d \igobs d_0$]
    {$d$ $\igobs$ definir($d, k, s$)}
    [$\Theta(|k| + copy(s))$]
    [define la clave $k$ $\not\in$ claves($d$) con el significado $s$ en el diccionario.]
    [los elementos $k$ y $s$ se definen por copia.]

    \InterfazFuncion{Definido?}{\In{d}{diccTrie($string$, $\alpha$)}, \In{k}{$string$}}{bool}
    {$res$ $\igobs$ def?($d$, $k$)}
    [$\BigO(|k|)$]
    [devuelve \texttt{true} si y s�lo $k$ est� definido en el diccionario.]

    \InterfazFuncion{Significado}{\In{d}{diccTrie($string$, $\alpha$)}, \In{k}{$string$}}{$\sigma$}
    [def?($d$, $k$)]
    {alias($res$ $\igobs$ obtener($d$, $k$))}
    [$\Theta(|k|)$]
    [devuelve el significado de la clave $k$ en $d$.]
    [$res$ es modificable si y gus�lo si $d$ es modificable.]

  \end{Interfaz}

  \begin{Representacion}
    
    \Titulo{Representaci�n del diccionario}
    \begin{Estructura}{diccTrie$(string, \alpha)$}[estr]

      \begin{Tupla}[estr]%
        \tupItemF{raiz}{puntero(nodo)},\\
        \tupItemF{claves}{conj(string)}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[nodo]
        \tupItem{significado}{puntero($\alpha$)}\\
        \tupItemF{siguientes}{arreglo(puntero(nodo))[256]}
      \end{Tupla}

    \end{Estructura}

    \Rep[diccTrie][d]{\\
      (Los nodos del diccionario (excepto la raiz) tienen un unico padre. Es decir, no hay dos Nodos en la estructura que tengan punteros iguales en los siguientes del Nodo. $\land$\\
      La raiz no tiene padre. Es decir, no hay un camino de hijos por el cual se llegue a dicho Nodo. $\land$\\
      Todas las hojas tienen un significado distinto de NULL.\\
      Un s string pertenece a d.claves si y solo si se puede seguir un camino de nodos en el diccionario con los caracteres de s (en orden) llegando finalemente al ultimo nodo (correspondiente a la ultima letra) teniendo este significado distinto de NULL) \\ \\
      // La primer condicion implica que no hay ciclos ni Nodos con hijos de menor nivel\\
    }

    ~

    \Abs[estr]{diccTrie($string$, $\alpha$)}[e]{d}{ \\
      (\paratodo s : string)(def?(s,d) $\igobs$ estaDefinido(e.raiz, s)) $\land$ \\
      (\paratodo s : string)(def?(s,d) $\impluego$ obtener(s, d) $\igobs$ significado(e.raiz, s)) $\land$ \\
      claves(d) $\igobs$ e.claves}\\ 
    
    estaDefinido(r, s) $\equiv$ 
    \textbf{if} vacia?(s) \\
    \ttab \textbf{then} r $\DRef$ significado $\neq$ NULL \\ 
    \ttab \textbf{else} r $\DRef$ sigueintes[int(prim(s))] $\neq$ NULL $\yluego$ estaDefinido(r.siguientes[int(prim(s))], fin(s)) 
    \textbf{fi} \\

    significado(r,s)  $\equiv$ 
    \textbf{if} vacia?(s) \\
    \ttab \textbf{then} r $\DRef$ significado \\ 
    \ttab \textbf{else} significado(r.siguientes[int(prim(s))], fin(s)) 
    \textbf{fi} \\

  \end{Representacion}
  \begin{Algoritmos}

    \begin{algorithm}[H]{\textbf{iVac�a}() $\to$ $res$ : estr}
      \begin{algorithmic}[1]
           \State // Le asigna un nuevo nodo a la raiz
           \State $res \gets \tuple{raiz: nuevoNodo()}$				\Comment $\Theta(1)$
    
          \medskip
          \Statex \underline{Complejidad:} $\Theta(1)$
          \Statex \underline{Justificaci�n:} La complejidad de crear un nuevo nodo es $\Theta(1)$
          \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iSignificado}(\Inout{d}{estr}, \In{k}{$string$})$\to$ $res$ : $\alpha$}
      \begin{algorithmic}[1]
        \State $Nodo \ actual \gets d.raiz$                                                      \Comment $\Theta(1)$

        \State $\textbf{for} \ (char \ c \ : \ k) \ \ \textbf{do}$                               \Comment $\BigO(|k|)$  
        \State \tab $actual \gets (actual \DRef siguientes [toInt(c)])$       \Comment $\Theta(1)$
        \State $\textbf{end for}$                                    

        \State $res \gets *(actual \DRef significado)$                                            \Comment $\Theta(1)$

          \medskip
          \Statex \underline{Complejidad:} $\Theta(|k|)$
          \Statex \underline{Justificaci�n:} Los accesos y las asignaciones de punteros son $\Theta(1)$. Como el ciclo se ejecuta |k| veces, se ejecutaran dichas asignaciones |k| veces. Luego la complejidad ser� $\Theta(|k|)$.
          \end{algorithmic}
    \end{algorithm}


    \begin{algorithm}[H]{\textbf{iDefinido?}(\Inout{d}{estr}, \In{k}{$string$}) $\to$ $res$ : bool}
      \begin{algorithmic}[1]
           \State $Nodo \ actual \gets d.raiz$                                                      \Comment $\Theta(1)$

           \State $\textbf{for} \ (char \ c \ : \ k) \ \ \textbf{do}$                               \Comment $\BigO(|k|)$  
           \State \tab  $\textbf{if} \ (actual \DRef siguientes [toInt(c)] \ \neq  \ NULL) $        \Comment $\Theta(1)$
           \State \ttab   $\textbf{then} \ actual \gets (actual \DRef siguientes [toInt(c)])$       \Comment $\Theta(1)$
           \State \ttab  $\textbf{else} \ res \gets false$                                           \Comment $\Theta(1)$
           \State \tab $\textbf{end if}$
           \State $\textbf{end for}$                                    

           \State $res \gets ((actual \DRef significado) \neq NULL)$                                                                  \Comment $\Theta(1)$

          \medskip
          \Statex \underline{Complejidad:} $\BigO(|k|)$
          \Statex \underline{Justificaci�n:} Los accesos y las asignaciones de punteros son $\Theta(1)$. Como el ciclo se ejecuta a lo sumo |k| veces, se ejecutaran dichas asignaciones |k| veces como m�ximo. Luego la complejidad ser� $\BigO(|k|)$.
          \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iDefinir}(\Inout{d}{estr}, \In{k}{$string$}, \In{s}{$\alpha$}) $\to$ $res$ : $\alpha$}
      \begin{algorithmic}[1]
          \State $Nodo \ actual \gets d.raiz$
          \State $\textbf{for} \ (char \ c \ : \ k) \ \ \textbf{do}$                                          \Comment $\Theta(|k|)$  
          \State \tab   // Si no tengo siguiente, lo creo
          \State \tab   $\textbf{if} \ (actual \DRef siguientes [toInt(c)] \ == \ NULL) \ \ \textbf{then}$    \Comment $\Theta(1)$
          \State \ttab  $\ actual \DRef siguientes[toInt(c)] = nuevoNodo()$                                   \Comment $\Theta(1)$
          \State \tab   $\textbf{end if}$
          \State \tab   $actual \gets (actual \DRef siguientes [toInt(c)])$                                   \Comment $\Theta(1)$
          \State $\textbf{end for}$  
          \State
          \State // Estoy parado en el nodo que va a tener el puntero al significado.
          \State // Reservo un lugar en memoria y hago una copia del provisto en dicho lugar.
          \State $sig \gets s$                                                                                \Comment $\Theta(copy(s))$
          \State // Asigno al significado del nodo el puntero creado con s.
          \State $(actual \DRef significado) \gets \&sig$                                                     \Comment $\Theta(1)$
          \State // Agrego la nueva clave al conjunto de claves 
          \State // Como precondicion, se que no existe asi que la agrego rapido
          \State AgregarRapido(e.claves, k)                                                                   \Comment $\Theta(copy(k))$
          \State // Devuelvo por referencia el significado.
          \State res $\gets sig$                                                                              \Comment $\Theta(1)$

          \medskip
          \Statex \underline{Complejidad:} $\Theta(|k| + copy(s))$
          \Statex \underline{Justificaci�n:} Siempre se recorre toda la palabra para definirla, entonces el $for$ siempre tiene $|k|$ ciclos. La dereferenciaci�n y comparaci�n de punteros, e indexaci�n en arreglos est�ticos son $\Theta(1)$.
          \end{algorithmic}
    \end{algorithm}
  
    \begin{algorithm}[H]{\textbf{inuevoNodo}() $\to$ $res$ : puntero(nodo)} \Comment Funci�n privada que crea un nuevo nodo
      \begin{algorithmic}[1]
           \State // Reserva la memoria para un nuevo nodo con significado null y siguientes vac�os
           \State $res \gets \& \tuple{significado: NULL, \ siguientes: arreglo\_estatico[256] \ de\ puntero(Nodo)}$ 				\Comment $\Theta(1)$
    
          \medskip
          \Statex \underline{Complejidad:} $\Theta(1)$
          \Statex \underline{Justificaci�n:} El tiempo de creaci�n de un array de 255 posiciones es $\BigO(255) \in \BigO(1)$
          \end{algorithmic}
    \end{algorithm}
  \end{Algoritmos}

  \begin{algorithm}[H]{\textbf{iClaves}(\In{d}{estr})$\to$ $res$ : conj(string)}
    \begin{algorithmic}[1]
      \State $res \gets e.claves$                                            \Comment $\Theta(1)$

        \medskip
        \Statex \underline{Complejidad:} $\Theta(1)$
        \end{algorithmic}
  \end{algorithm}


\newpage

\section{M�dulo Juego}

  Aqui va la descripci�n

  \begin{Interfaz}
    \textbf{generos}: \TipoVariable{juego}.

    \textbf{se explica con}: \tadNombre{Juego}.

    \Titulo{Operaciones b�sicas de Juego}
    
    % Generadores
    \InterfazFuncion{iniciar}{\In{m}{mapa},�\In{pjs}{conj(jugador)}, \In{eventosFan}{vector(evento))}}{juego}%
    [$\neg vacio(pjs) \land (\forall e: evento) (est�?(e, eventosFan) \impluego e.pos \in libres(m))$]
    {$res \igobs nuevoJuego(m, pjs, eventosFan)$}%
    [$\Theta(?)$ TODO]
    [crea un nuevo juego con el mapa dado, un conjunto de jugadores, y los eventos de un fantasma.]

    \InterfazFuncion{pasarTiempo}{\In{j}{juego}}{juego}%
    {$res \igobs pasar(j)$}%
    [$\Theta(?)$]
    [ejecuta un paso de tiempo cuando ning�n jugador realiza una acci�n.]

    \InterfazFuncion{ejecutarAccion}{\In{j}{juego}, \In{a}{accion}, \In{pj}{jugador}}{juego}%
    [$pj \in jugadores(j) \yluego jugadorVivo(pj, j) \land \neg esPasar(a)$]
    {$res \igobs step(j, a, pj)$}%
    [$\Theta(?)$]
    [actualiza con la acci�n $a$ del jugador $pj$.]


    % Pedidas por enunciado
    \InterfazFuncion{jugadoresVivos}{\In{j}{juego}}{conj(puntero(infoPJ))}%
    {$(\forall p : puntero(infoPJ)) (p \in res \impluego\\
    \tttab (p\rightarrow id \in jugadores(j)) \yluego \\
    \tttab (p\rightarrow vivo? \land jugadorVivo(p\rightarrow id, j)) \land \\
    \tttab ((\forall e : evento) (e \in p\rightarrow eventos \impluego \\
    \ttttab (e.pos \igobs posJugador(p\rightarrow id, j)) \land \\
    \ttttab (e.dir \igobs dirJugador(p\rightarrow id, j))) 
    )$}%
    [$\Theta(1)$]
    [devuelve un conjunto con punteros a la informaci�n de los personajes que est�n vivos.]
    [res es no modificable.]
  
    \InterfazFuncion{fantasmasVivos}{\In{j}{juego}}{conj(infoFan)}%
    {$fantasmaValido(j, res)$}%
    [$\Theta(1)$]
    [devuelve un conjunto referencias a la informaci�n de los fantasmas que est�n vivos.]
    [las referencias son no modificables.]

    \InterfazFuncion{fantasmaEspecial}{\In{j}{juego}}{infoFan}
    {$res \igobs fantasmaEspecial(j)$}
    [$\Theta(1)$]
    [devuelve el fantasma especial.]
    [res es una referencia no modificable.]

    \InterfazFuncion{fantasmasVivosQueDisparan}{\In{j}{juego}}{conj(infoFan)}
    {$fantasmaValido(j, res) \yluego\\
    \ttab ((\forall f : infoFan) (f \in res \impluego disparando(f.eventos, step(j)))$}
    [$O(\#fv)$]
    [devuelve un conjunto con punteros a la informaci�n de los fantasmas que est�n vivos y disparan en el ultimo paso ejecutado en el juego.]
    [res es un conjunto de referencias no modificables.]

    \InterfazFuncion{vivo?}{\In{j}{juego}, \In{pj}{string}}{bool}
    [$pj \in jugadores(j)$]
    {$res \igobs jugadorVivo(pj, j)$}
    [$O(|j|)$]
    [devuelve si un jugador est� vivo]

    \InterfazFuncion{posOcupadasPorDisparos}{\In{j}{juego}}{conj(posicion)}
    {$res \igobs alcanceDisparosFantasmas(fantasmas(j), j)$}
    [$O(\#fv * m)$]
    [devuelve un conjunto de las posiciones afectadas por disparos de fantasmas en la �ltima *ronda* (TODO: ronda o paso?).]


    Predicados auxiliares:

    fantasmaValido(j, fs):\\
    $\tab (\forall f : infoFan) (f \in res \impluego\\
    \ttab (f.eventos \in fantasmas(j)) \yluego \\
    \ttab (fantasmaVivo(f.eventos, j)) \land \\
    \ttab ((\forall e : evento) (e \in f.eventos \impluego \\
    \tttab (e.pos \igobs posFantasma(f.eventos, j)) \land \\
    \tttab (e.dir \igobs dirFantasma(f.eventos, j))))$

  \end{Interfaz}

  \begin{Representacion}
    
    \Titulo{Representaci�n de Juego}
    \begin{Estructura}{juego}[estr]
      \begin{Tupla}[j]
        \Comentario{General}
        \tupItem{paso}{nat}\\
        \tupItem{ronda}{nat}\\
        \tupItem{mapa}{m}\\

        \Comentario{Disparos}
        \tupItem{mapaDisparos}{arreglo(arreglo(tupla(nat, nat)))}\\
        \tupItem{disparosUltimoPaso}{conj(posicion)}\\

        \Comentario{Jugadores}
        \tupItem{infoJugadores}{diccTrie(string, infoPJ)}\\
        \tupItem{infoActualJugadoresVivos}{conj(infoActualPJ)}\\
        \tupItem{infoJugadoresVivos}{conj(puntero(infoPJ))}\\

        \Comentario{Fantasmas}
        \tupItem{infoFantasmas}{conj(infoFan)}\\
        \tupItem{infoActualFantasmasVivos}{conj(infoActualFan)}\\
        \tupItem{infoFantasmasVivos}{conj(itConj(infoFan))}\\
        \tupItemF{infoFantasmaEspecial}{itConj(infoActualFan)}
      \end{Tupla}
      
      \mbox{}

      \begin{Tupla}[infoPJ]
        \tupItem{eventos}{vector(evento)}\\
        \tupItem{vivo?}{bool}\\
        % Solo cuando est� vivo
        \tupItemF{infoActual}{itConj(infoActualPJ)}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[infoActualPJ]
        \tupItem{identidad}{string}\\
        \tupItem{posicion}{pos}\\
        \tupItemF{direccion}{dir}
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[infoFan]
        \tupItem{infoActual}{itConj(infoActualFan)}\\
        \tupItemF{eventos}{vector(evento)} 
      \end{Tupla}

      \mbox{}

      \begin{Tupla}[infoActualFan]
        \tupItem{posicion}{pos}\\
        \tupItemF{direccion}{dir}
      \end{Tupla}

    \end{Estructura}

    \Rep[mapa][m]{}
    
    \mbox{}
    \Abs[mapa]{hab}[m]{h}{}

  \end{Representacion}

  \bigskip

  \begin{Algoritmos}

  En esta secci�n se hace abuso de notaci�n en los c�lculos de �lgebra de �rdenes presentes en la justificaciones de los algoritmos. La operaci�n de suma ``+'' denota secuencializaci�n de operaciones con determinado orden de complejidad, y el s�mbolo de igualdad ``='' denota la pertenencia al orden de complejidad resultante.

  \medskip
    
  \Titulo{Algoritmos del m�dulo}
      \medskip
    
  \begin{algorithm}[H]{\textbf{iIniciar}(\In{m}{mapa}, \In{pjs}{conj(jugador)}, \In{eventosFan}{vector(evento)}) $\to$ $res$ : estr}
        \begin{algorithmic}[1]
        \State // Inicializo la estructura
        \State $res: \langle$
        \State \tab // Inicializo contadores
        \State \tab $paso : 0,$                     \Comment $\Theta(1)$
        \State \tab $ronda : 0,$                     \Comment $\Theta(1)$
        \\
        \State \tab // Seteo el mapa 
        \State \tab $mapa: m,$                     \Comment $\Theta(1)$
        \\
        \State \tab // Inicializo el mapa de disparos con el mismo tama�o que el mapa
        \State \tab $mapaDisparos: arreglo(arreglo(tupla(nat, nat))[Tam(m)])[Tam(m)],$ \Comment $\Theta(Tam(m)^2)$
        \State \tab $disparosUltimoPaso: Vacio(),$ \Comment $\Theta(1)$
        \\
        \State \tab // Inicializo estructuras de jugadores y fantasmas como vac�as
        \State \tab $infoActualJugadoresVivos: Vacio(),$
        \State \tab $infoJugadoresVivos: Vacio(),$
        \State \tab $infoJugadores: Vacia(),$
        \State \tab $infoFantasmas: Vacio(),$
        \State \tab $infoActualFantasmasVivos: Vacio(),$
        \State \tab $infoFantasmasVivos: Vacia(),$
        \State \tab $infoFantasmaEspecial: CrearIt(Vacio())$ % TODO
        \State $\rangle$
        \\
        \State // Suponemos la existencia de la funci�n
        \State // $dict(jugador,\ tupla(pos, dir))\ localizarJugadores(m,\ conj(jugador)\ pjs)$ 
        \\
        \State // Obtengo las posiciones y direcciones de jugadores
        \State $localPJs \gets localizarJugadores(m, pjs)$ \
        \\
        \State // Lleno las estructuras de jugadores
        \State $\textbf{for} \ (j,\ localizacion : \ localPJs) \ \ \textbf{do}$
        \State \tab // Creo la infoActual y la agrego a su conjunto
        \State \tab $infoActual \gets \tuple{identidad: j,\ posicion: localizacion.pos,\ direccion: localizacion.dir}$
        \State \tab $itInfoActual \gets AgregarRapido(res.infoActualJugadoresVivos,\ infoActual)$
        \\
        \State \tab // Creo la infoPJ con la actual
        \State \tab $info \gets iNuevaInfoPJ(j,\ localizacion,\ itInfoActual)$
        \State \tab // La agrego al trie y me guardo el puntero a la info guardada
        \State \tab $infoPtr \gets \& Definir(res.infoJugadores,\ j,\ info)$
        \\
        \State \tab // Agrego al conjunto de jugadores vivos el puntero a la info del PJ
        \State \tab $AgregarRapido(res.infoJugadoresVivos,\ infoPtr)$
        \State $\textbf{end for}$
        \\
        \State // Lleno las estructuras de fantasmas
        \State // Creo la infoActual y la agrego a su conjunto
        \State $infoActualFan \gets \tuple{posicion: eventosFan[0].pos,\ direccion: eventosFan[0].dir}$
        \State $itInfoActualFan \gets AgregarRapido(infoActualFan, res.infoActualFantasmasVivos)$
        \\
        \State // Hago que el fantasma especial sea este
        \State $res.infoFantasmaEspecial \gets itInfoActualFan$
        \\
        \State // Creo la infoFan con la actual
        \State $infoFan \gets \tuple{infoActual: itInfoActualFan,\ eventos: eventosFan}$
        \State // La agrego al conjunto de informaci�n de fantasmas y me guardo su iterador
        \State $itInfoFan \gets AgregarRapido(infoFan,\ res.infoFantasmas)$
        \\
        \State // Agrego al conjunto de fantasmas vivos el interador a la info del Fan
        \State $AgregarRapido(itInfoFan,\ res.infoFantasmasVivos)$
        \medskip
        \Statex \underline{Complejidad:} $\Theta(?)$
        \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iPasarTiempo}(\In{j}{estr})}
    \begin{algorithmic}[1]
      \State
      // Aumentas paso
      // Por cada fantasma
      //  Si dispara
      //    Agregar disparo
      //      Agregas el disparo al conjunto (inteligentemente)
      //      Agregas las pos afectadas al mapa de disparos
      //    
      //  Actualizo la info actual
      // Por cada jugador
      //  Te fijas si muere
      //  Actualizas la info actual
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iEjecutarAccion}(\In{j}{estr}, \In{a}{accion}, \In{pj}{jugador}) $\to res$ :estr}
    \begin{algorithmic}[1]
      \State
    \end{algorithmic}
  \end{algorithm}


  \end{Algoritmos}

\newpage

\section{M�dulo Mapa}

Aqui va la descripci�n

\begin{Interfaz}
  
  \textbf{generos}: \TipoVariable{mapa}.

  \textbf{se explica con}: \tadNombre{Habitaci�n}.

  \Titulo{Operaciones b�sicas del mapa}
  \InterfazFuncion{nuevoMapa}{\In{n}{nat}}{mapa}%
  {$res \igobs nuevaHab(n)$}%
  [$\Theta(n^2)$]
  [genera un mapa de tamano n x n.]

  \InterfazFuncion{ocupar}{\Inout{m}{mapa}, \In{c}{$tupla(int, int)$}}{}%
  [$m \igobs m_0$ $\land$ $c \in casilleros(m)$ $\yluego$ $libre(m, c)$ $\land$ $alcanzan(libres(m)-c, libres(m)-c, m)$]
  %lo de m = m0 es igualdad observacional, no?
  {$m$ $\igobs$ $ocupar(c,m_0)$}%
  [$\Theta(1)$]
  [ocupa una posicion del mapa siempre y cuando este no deje de ser conexo.]

  \InterfazFuncion{tam}{\In{m}{mapa}}{nat}%
  {$res$ $\igobs$ $tam(m)$}%
  [$\Theta(1)$]
  [devuelve el tamano del mapa.]
    
  \InterfazFuncion{libre}{\In{m}{mapa}, \In{c}{$tupla(int, int)$}}{bool}%
  [$c \in casilleros(m)$]%
  {$res$ $\igobs$ $libre(c, m)$}
  [$\Theta(1)$]
  [devuelve si un elemento esta ocupado.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representaci�n del mapa}

  El objetivo de este m�dulo es implementar una lista doblemente enlazada con punteros al principio y al fin.  Para simplificar un poco el manejo de la estructura, vamos a reemplazarla por una lista circular, donde el siguiente del �ltimo apunta al primero y el anterior del primero apunta al �ltimo.  La estructura de representaci�n, su invariante de representaci�n y su funci�n de abstracci�n son las siguientes.

  \begin{Estructura}{mapa}[m]
    \begin{Tupla}[m]
      \tupItem{tamano}{nat}%
      \tupItem{casilleros}{vec(vec(bool))}%
    \end{Tupla}
  \end{Estructura}

  \Rep[mapa][m]{
    La longitud de m.casilleros es igual a tamano $\land$\\
    La longitud del vector m.casilleros es igual a la de todo otro vector dentro de el) $\land$\\
    Es conexa % Trivial
  }\mbox{}

  \Abs[mapa]{hab}[m]{h}{$m.tamano$ $\igobs$ $tam(h)$ $\yluego$\\
    ($\forall t$: tuple(nat,nat))($0 \leq$ $\Pi_1(t)$, $\Pi_2(t) < m.tamano - 1$ $\impluego$\\
    libre(m, t) $\igobs$ $m.casilleros[\Pi_1(t)][\Pi_2(t)]$)}

\end{Representacion}

\bigskip

\begin{Algoritmos}

En esta secci�n se hace abuso de notaci�n en los c�lculos de �lgebra de �rdenes presentes en la justificaciones de los algoritmos. La operaci�n de suma ``+'' denota secuencializaci�n de operaciones con determinado orden de complejidad, y el s�mbolo de igualdad ``='' denota la pertenencia al orden de complejidad resultante.

\medskip
	
 \Titulo{Algoritmos del m�dulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iTam}(\In{m}{mapa}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
       \State $res \gets m.tamano$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iOcupar}(\Inout{m}{mapa}, \In{c}{tupla(int, int)})}
  \begin{algorithmic}[1]
			 \State $m[\Pi_1(c)][\Pi_2(c)] \gets true$ 				\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
      \Statex \underline{Justificaci�n:} El acceso a una posici�n de un vector y su modificaci�n es $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iLibre}(\In{m}{mapa}, \In{c}{tupla(int, int)}) $\to$ $res$ : bool}
	\begin{algorithmic}[1]
			 \State $res \gets \neg \ m[\Pi_1(c)][\Pi_2(c)]$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificaci�n:} El acceso a una posici�n de un vector es $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	

\begin{algorithm}[H]{\textbf{iNuevoMapa}(\In{n}{nat}) $\to$ $res$ : $mapa$}
  \begin{algorithmic}[1]
      \State $m.tamano \gets n$                   \Comment $\Theta(1)$
      \State $v \gets Vacia()$	                  \Comment $\Theta(1)$
      \State $i \gets 0$                          \Comment $\Theta(1)$
      \While{$i < n$}                             \Comment $O(n)$
        \State $v.AgregarAtras(false)$
        \State $i \gets i + 1$
      \EndWhile
      \State $i \gets 0$
      \While{$i < n$}                             \Comment $O(n^2)$
        \State $res.AgregarAtras(v.Copiar())$     \Comment $O(n)$
        \State $i \gets i + 1$                    \Comment $O(1)$
      \EndWhile
      \medskip
      \Statex \underline{Complejidad:} $\Theta(n^2)$
      \Statex \underline{Justificaci�n:} Copiar un vector de n booleanos es $O(n * copy(bool))$ y copiar un bool es $\Theta(1)$. Luego, agregar n veces la copia del vector es $O(n^2)$
    	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\newpage

\section{M�dulo Direcci�n}

Aqui va la descripci�n

\begin{Interfaz}
  \textbf{generos}: \TipoVariable{dir}.

  \textbf{se explica con}: \tadNombre{Direcci�n}.

  \Titulo{Operaciones b�sicas de Direcci�n}

  \InterfazFuncion{arriba}{}{dir}%
  {$res \igobs  \uparrow$}%
  [$\Theta(1)$]
  [genera la direcci�n arriba.]

  \InterfazFuncion{abajo}{}{dir}%
  {$res \igobs  \downarrow$}%
  [$\Theta(1)$]
  [genera la direcci�n abajo.]

  \InterfazFuncion{izquierda}{}{dir}%
  {$res \igobs  \leftarrow$}%
  [$\Theta(1)$]
  [genera la direcci�n izquierda.]

  \InterfazFuncion{derecha}{}{dir}%
  {$res \igobs  \rightarrow$}%
  [$\Theta(1)$]
  [genera la direcci�n derecha.]

  \InterfazFuncion{invertir}{\Inout{d}{dir}}{}
  {$res \igobs invertir(d)$}
  [$\Theta(1)$]
  [invierte la direcci�n.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representaci�n de Direcci�n}

  \begin{Estructura}
    {dir}[string]
  \end{Estructura}

  \Rep[dir][d]{\\
    d \igobs $"arriba"$    $\lor$\\
    d \igobs $"abajo"$     $\lor$\\
    d \igobs $"izquierda"$ $\lor$\\
    d \igobs $"derecha"$
  }
  
  \mbox{}

  \Abs[dir]{dir}[d]{d$_{tad}$}{(d \igobs $"arriba"$  $\land$ d$_{tad}$ \igobs $\uparrow$) $\lor$\\
  (d \igobs $"abajo"$     $\land$ d$_{tad}$ \igobs $\uparrow$)   $\lor$\\
  (d \igobs $"izquierda"$ $\land$ d$_{tad}$ \igobs $\leftarrow$) $\lor$\\
  (d \igobs $"derecha"$   $\land$ d$_{tad}$ \igobs $\rightarrow$)
  }

\end{Representacion}

\bigskip

\begin{Algoritmos}
  \Titulo{Algoritmos del m�dulo}
  \medskip
  
  \begin{algorithm}[H]{\textbf{iArriba}() $\to$ $res$ : dir}
    	\begin{algorithmic}[1]
       \State $res \gets "arriba"$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iAbajo}() $\to$ $res$ : dir}
    \begin{algorithmic}[1]
     \State $res \gets "abajo"$ \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}
  
  \begin{algorithm}[H]{\textbf{iIzquierda}() $\to$ $res$ : dir}
    \begin{algorithmic}[1]
     \State $res \gets "izquierda"$ \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}


  \begin{algorithm}[H]{\textbf{iDerecha}() $\to$ $res$ : dir}
    \begin{algorithmic}[1]
     \State $res \gets "derecha"$ \Comment $\Theta(1)$
    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

  \begin{algorithm}[H]{\textbf{iInvertir}(\Inout{d}{dir})}
    \begin{algorithmic}[1]
     \State $switch(d)$         \Comment $\Theta(1)$
     \State $case\ "arriba":$
     \State $\tab d \gets "abajo"$
     \State $case\ "abajo":$
     \State $\tab d \gets "arriba"$ %skere
     \State $case\ "izquierda":$
     \State $\tab d \gets "derecha"$
     \State $case\ "derecha":$
     \State $\tab d \gets "izquierda"$

    \medskip
    \Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
  \end{algorithm}

\end{Algoritmos}

\newpage

\section{M�dulo Acci�n}

Aqui va la descripci�n

\begin{Interfaz}
  \textbf{generos}: \TipoVariable{accion}.

  \textbf{se explica con}: \tadNombre{Acci�n}.

  \Titulo{Operaciones b�sicas de Acci�n}
  \InterfazFuncion{mover}{\In{d}{dir}}{accion}%
  {$res \igobs mover(d)$}%
  [$\Theta(1)$]
  [genera una acci�n de mover en la direcci�n especificada.]
  
  \InterfazFuncion{pasar}{}{accion}%
  {$res \igobs pasar$}%
  [$\Theta(1)$]
  [genera la acci�n de pasar.]

  \InterfazFuncion{disparar}{}{accion}%
  {$res \igobs disparar$}%
  [$\Theta(1)$]
  [genera la acci�n de disparar.]

  \InterfazFuncion{aplicar}{}{tupla()}%
  {$res \igobs disparar$}%
  [$\Theta(1)$]
  [genera la acci�n de disparar.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representaci�n de Acci�n}

  El objetivo de este m�dulo es implementar una lista doblemente enlazada con punteros al principio y al fin.  Para simplificar un poco el manejo de la estructura, vamos a reemplazarla por una lista circular, donde el siguiente del �ltimo apunta al primero y el anterior del primero apunta al �ltimo.  La estructura de representaci�n, su invariante de representaci�n y su funci�n de abstracci�n son las siguientes.

  \begin{Estructura}{mapa}[m]
    \begin{Tupla}[m]
      \tupItem{tamano}{nat}%
      \tupItem{casilleros}{vec(vec(bool))}%
    \end{Tupla}
  \end{Estructura}

  \Rep[mapa][m]{
    La longitud de m.casilleros es igual a tamano $\land$\\
    La longitud del vector m.casilleros es igual a la de todo otro vector dentro de el) $\land$\\
    Es conexa % Trivial
  }
  
  \mbox{}

  \Abs[mapa]{hab}[m]{h}{$m.tamano$ $\igobs$ $tam(h)$ $\yluego$\\
    ($\forall t$: tuple(nat,nat))($0 \leq$ $\Pi_1(t)$, $\Pi_2(t) < m.tamano - 1$ $\impluego$\\
    libre(m, t) $\igobs$ $m.casilleros[\Pi_1(t)][\Pi_2(t)]$)}

\end{Representacion}

\bigskip

\begin{Algoritmos}

En esta secci�n se hace abuso de notaci�n en los c�lculos de �lgebra de �rdenes presentes en la justificaciones de los algoritmos. La operaci�n de suma ``+'' denota secuencializaci�n de operaciones con determinado orden de complejidad, y el s�mbolo de igualdad ``='' denota la pertenencia al orden de complejidad resultante.

\medskip
	
 \Titulo{Algoritmos del m�dulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iTam}(\In{m}{mapa}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
       \State $res \gets m.tamano$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
\end{Algoritmos}

\newpage


\end{document}